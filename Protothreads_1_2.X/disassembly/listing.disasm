Disassembly Listing for Protothreads_1_2
Generated From:
Z:/EEdocs/4760/PIC/Neural_model_pt_1_2/Protothreads_1_2.X/dist/default/production/Protothreads_1_2.X.production.elf
Jan 4, 2017 10:14:22 AM

---  z:/eedocs/4760/pic/neural_model_pt_1_2/pt_cornell_1_2_1.h  -----------------------------------------
1:                   /* 
2:                    * File:   pt_cornell_1_2_1.h
3:                    * Author: brl4
4:                    *
5:                    * Created on Sept 22, 2015
6:                    */
7:                   
8:                   /*
9:                    * Copyright (c) 2004-2005, Swedish Institute of Computer Science.
10:                   * All rights reserved.
11:                   *
12:                   * Redistribution and use in source and binary forms, with or without
13:                   * modification, are permitted provided that the following conditions
14:                   * are met:
15:                   * 1. Redistributions of source code must retain the above copyright
16:                   *    notice, this list of conditions and the following disclaimer.
17:                   * 2. Redistributions in binary form must reproduce the above copyright
18:                   *    notice, this list of conditions and the following disclaimer in the
19:                   *    documentation and/or other materials provided with the distribution.
20:                   * 3. Neither the name of the Institute nor the names of its contributors
21:                   *    may be used to endorse or promote products derived from this software
22:                   *    without specific prior written permission.
23:                   *
24:                   * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
25:                   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
26:                   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
27:                   * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
28:                   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
29:                   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
30:                   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
31:                   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
32:                   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
33:                   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
34:                   * SUCH DAMAGE.
35:                   *
36:                   * This file is part of the Contiki operating system.
37:                   *
38:                   * Author: Adam Dunkels <adam@sics.se>
39:                   *
40:                   * $Id: pt.h,v 1.7 2006/10/02 07:52:56 adam Exp $
41:                   */
42:                  #include <plib.h>
43:                  /**
44:                   * \addtogroup pt
45:                   * @{
46:                   */
47:                  
48:                  /**
49:                   * \file
50:                   * Protothreads implementation.
51:                   * \author
52:                   * Adam Dunkels <adam@sics.se>
53:                   *
54:                   */
55:                  
56:                  #ifndef __PT_H__
57:                  #define __PT_H__
58:                  
59:                  ////////////////////////
60:                  //#include "lc.h"
61:                  ////////////////////////
62:                  /**
63:                   * \file lc.h
64:                   * Local continuations
65:                   * \author
66:                   * Adam Dunkels <adam@sics.se>
67:                   *
68:                   */
69:                  
70:                  #ifdef DOXYGEN
71:                  /**
72:                   * Initialize a local continuation.
73:                   *
74:                   * This operation initializes the local continuation, thereby
75:                   * unsetting any previously set continuation state.
76:                   *
77:                   * \hideinitializer
78:                   */
79:                  #define LC_INIT(lc)
80:                  
81:                  /**
82:                   * Set a local continuation.
83:                   *
84:                   * The set operation saves the state of the function at the point
85:                   * where the operation is executed. As far as the set operation is
86:                   * concerned, the state of the function does <b>not</b> include the
87:                   * call-stack or local (automatic) variables, but only the program
88:                   * counter and such CPU registers that needs to be saved.
89:                   *
90:                   * \hideinitializer
91:                   */
92:                  #define LC_SET(lc)
93:                  
94:                  /**
95:                   * Resume a local continuation.
96:                   *
97:                   * The resume operation resumes a previously set local continuation, thus
98:                   * restoring the state in which the function was when the local
99:                   * continuation was set. If the local continuation has not been
100:                  * previously set, the resume operation does nothing.
101:                  *
102:                  * \hideinitializer
103:                  */
104:                 #define LC_RESUME(lc)
105:                 
106:                 /**
107:                  * Mark the end of local continuation usage.
108:                  *
109:                  * The end operation signifies that local continuations should not be
110:                  * used any more in the function. This operation is not needed for
111:                  * most implementations of local continuation, but is required by a
112:                  * few implementations.
113:                  *
114:                  * \hideinitializer 
115:                  */
116:                 #define LC_END(lc)
117:                 
118:                 /**
119:                  * \var typedef lc_t;
120:                  *
121:                  * The local continuation type.
122:                  *
123:                  * \hideinitializer
124:                  */
125:                 #endif /* DOXYGEN */
126:                 
127:                 //#ifndef __LC_H__
128:                 //#define __LC_H__
129:                 
130:                 
131:                 //#ifdef LC_INCLUDE
132:                 //#include LC_INCLUDE
133:                 //#else
134:                 
135:                 /////////////////////////////
136:                 //#include "lc-switch.h"
137:                 /////////////////////////////
138:                 
139:                 //#ifndef __LC_SWITCH_H__
140:                 //#define __LC_SWITCH_H__
141:                 
142:                 /* WARNING! lc implementation using switch() does not work if an
143:                    LC_SET() is done within another switch() statement! */
144:                 
145:                 /** \hideinitializer */
146:                 /*
147:                 typedef unsigned short lc_t;
148:                 
149:                 #define LC_INIT(s) s = 0;
150:                 
151:                 #define LC_RESUME(s) switch(s) { case 0:
152:                 
153:                 #define LC_SET(s) s = __LINE__; case __LINE__:
154:                 
155:                 #define LC_END(s) }
156:                 
157:                 #endif /* __LC_SWITCH_H__ */
158:                 
159:                 /** @} */
160:                 
161:                 //#endif /* LC_INCLUDE */
162:                 
163:                 //#endif /* __LC_H__ */
164:                 
165:                 /** @} */
166:                 /** @} */
167:                 
168:                 /////////////////////////////
169:                 //#include "lc-addrlabels.h"
170:                 /////////////////////////////
171:                 
172:                 #ifndef __LC_ADDRLABELS_H__
173:                 #define __LC_ADDRLABELS_H__
174:                 
175:                 /** \hideinitializer */
176:                 typedef void * lc_t;
177:                 
178:                 #define LC_INIT(s) s = NULL
179:                 
180:                 #define LC_RESUME(s)				\
181:                   do {						\
182:                     if(s != NULL) {				\
183:                       goto *s;					\
184:                     }						\
185:                   } while(0)
186:                 
187:                 #define LC_CONCAT2(s1, s2) s1##s2
188:                 #define LC_CONCAT(s1, s2) LC_CONCAT2(s1, s2)
189:                 
190:                 #define LC_SET(s)				\
191:                   do {						\
192:                     LC_CONCAT(LC_LABEL, __LINE__):   	        \
193:                     (s) = &&LC_CONCAT(LC_LABEL, __LINE__);	\
194:                   } while(0)
195:                 
196:                 #define LC_END(s)
197:                 
198:                 #endif /* __LC_ADDRLABELS_H__ */
199:                 
200:                 
201:                 
202:                 //////////////////////////////////////////
203:                 struct pt {
204:                   lc_t lc;
205:                   int pri;
206:                 };
207:                 
208:                 #define PT_WAITING 0
209:                 #define PT_YIELDED 1
210:                 #define PT_EXITED  2
211:                 #define PT_ENDED   3
212:                 
213:                 /**
214:                  * \name Initialization
215:                  * @{
216:                  */
217:                 
218:                 /**
219:                  * Initialize a protothread.
220:                  *
221:                  * Initializes a protothread. Initialization must be done prior to
222:                  * starting to execute the protothread.
223:                  *
224:                  * \param pt A pointer to the protothread control structure.
225:                  *
226:                  * \sa PT_SPAWN()
227:                  *
228:                  * \hideinitializer
229:                  */
230:                 #define PT_INIT(pt)   LC_INIT((pt)->lc)
231:                 
232:                 /** @} */
233:                 
234:                 /**
235:                  * \name Declaration and definition
236:                  * @{
237:                  */
238:                 
239:                 /**
240:                  * Declaration of a protothread.
241:                  *
242:                  * This macro is used to declare a protothread. All protothreads must
243:                  * be declared with this macro.
244:                  *
245:                  * \param name_args The name and arguments of the C function
246:                  * implementing the protothread.
247:                  *
248:                  * \hideinitializer
249:                  */
250:                 #define PT_THREAD(name_args) char name_args
251:                 
252:                 /**
253:                  * Declare the start of a protothread inside the C function
254:                  * implementing the protothread.
255:                  *
256:                  * This macro is used to declare the starting point of a
257:                  * protothread. It should be placed at the start of the function in
258:                  * which the protothread runs. All C statements above the PT_BEGIN()
259:                  * invokation will be executed each time the protothread is scheduled.
260:                  *
261:                  * \param pt A pointer to the protothread control structure.
262:                  *
263:                  * \hideinitializer
264:                  */
265:                 #define PT_BEGIN(pt) { char PT_YIELD_FLAG = 1; LC_RESUME((pt)->lc)
266:                 
267:                 /**
268:                  * Declare the end of a protothread.
269:                  *
270:                  * This macro is used for declaring that a protothread ends. It must
271:                  * always be used together with a matching PT_BEGIN() macro.
272:                  *
273:                  * \param pt A pointer to the protothread control structure.
274:                  *
275:                  * \hideinitializer
276:                  */
277:                 #define PT_END(pt) LC_END((pt)->lc); PT_YIELD_FLAG = 0; \
278:                                    PT_INIT(pt); return PT_ENDED; }
279:                 
280:                 /** @} */
281:                 
282:                 /**
283:                  * \name Blocked wait
284:                  * @{
285:                  */
286:                 
287:                 /**
288:                  * Block and wait until condition is true.
289:                  *
290:                  * This macro blocks the protothread until the specified condition is
291:                  * true.
292:                  *
293:                  * \param pt A pointer to the protothread control structure.
294:                  * \param condition The condition.
295:                  *
296:                  * \hideinitializer
297:                  */
298:                 #define PT_WAIT_UNTIL(pt, condition)	        \
299:                   do {						\
300:                     LC_SET((pt)->lc);				\
301:                     if(!(condition)) {				\
302:                       return PT_WAITING;			\
303:                     }						\
304:                   } while(0)
305:                 
306:                 /**
307:                  * Block and wait while condition is true.
308:                  *
309:                  * This function blocks and waits while condition is true. See
310:                  * PT_WAIT_UNTIL().
311:                  *
312:                  * \param pt A pointer to the protothread control structure.
313:                  * \param cond The condition.
314:                  *
315:                  * \hideinitializer
316:                  */
317:                 #define PT_WAIT_WHILE(pt, cond)  PT_WAIT_UNTIL((pt), !(cond))
318:                 
319:                 /** @} */
320:                 
321:                 /**
322:                  * \name Hierarchical protothreads
323:                  * @{
324:                  */
325:                 
326:                 /**
327:                  * Block and wait until a child protothread completes.
328:                  *
329:                  * This macro schedules a child protothread. The current protothread
330:                  * will block until the child protothread completes.
331:                  *
332:                  * \note The child protothread must be manually initialized with the
333:                  * PT_INIT() function before this function is used.
334:                  *
335:                  * \param pt A pointer to the protothread control structure.
336:                  * \param thread The child protothread with arguments
337:                  *
338:                  * \sa PT_SPAWN()
339:                  *
340:                  * \hideinitializer
341:                  */
342:                 #define PT_WAIT_THREAD(pt, thread) PT_WAIT_WHILE((pt), PT_SCHEDULE(thread))
343:                 
344:                 /**
345:                  * Spawn a child protothread and wait until it exits.
346:                  *
347:                  * This macro spawns a child protothread and waits until it exits. The
348:                  * macro can only be used within a protothread.
349:                  *
350:                  * \param pt A pointer to the protothread control structure.
351:                  * \param child A pointer to the child protothread's control structure.
352:                  * \param thread The child protothread with arguments
353:                  *
354:                  * \hideinitializer
355:                  */
356:                 #define PT_SPAWN(pt, child, thread)		\
357:                   do {						\
358:                     PT_INIT((child));				\
359:                     PT_WAIT_THREAD((pt), (thread));		\
360:                   } while(0)
361:                 
362:                 /** @} */
363:                 
364:                 /**
365:                  * \name Exiting and restarting
366:                  * @{
367:                  */
368:                 
369:                 /**
370:                  * Restart the protothread.
371:                  *
372:                  * This macro will block and cause the running protothread to restart
373:                  * its execution at the place of the PT_BEGIN() call.
374:                  *
375:                  * \param pt A pointer to the protothread control structure.
376:                  *
377:                  * \hideinitializer
378:                  */
379:                 #define PT_RESTART(pt)				\
380:                   do {						\
381:                     PT_INIT(pt);				\
382:                     return PT_WAITING;			\
383:                   } while(0)
384:                 
385:                 /**
386:                  * Exit the protothread.
387:                  *
388:                  * This macro causes the protothread to exit. If the protothread was
389:                  * spawned by another protothread, the parent protothread will become
390:                  * unblocked and can continue to run.
391:                  *
392:                  * \param pt A pointer to the protothread control structure.
393:                  *
394:                  * \hideinitializer
395:                  */
396:                 #define PT_EXIT(pt)				\
397:                   do {						\
398:                     PT_INIT(pt);				\
399:                     return PT_EXITED;			\
400:                   } while(0)
401:                 
402:                 /** @} */
403:                 
404:                 /**
405:                  * \name Calling a protothread
406:                  * @{
407:                  */
408:                 
409:                 /**
410:                  * Schedule a protothread.
411:                  *
412:                  * This function shedules a protothread. The return value of the
413:                  * function is non-zero if the protothread is running or zero if the
414:                  * protothread has exited.
415:                  *
416:                  * \param f The call to the C function implementing the protothread to
417:                  * be scheduled
418:                  *
419:                  * \hideinitializer
420:                  */
421:                 #define PT_SCHEDULE(f) ((f) < PT_EXITED)
422:                 //#define PT_SCHEDULE(f) ((f))
423:                 
424:                 /** @} */
425:                 
426:                 /**
427:                  * \name Yielding from a protothread
428:                  * @{
429:                  */
430:                 
431:                 /**
432:                  * Yield from the current protothread.
433:                  *
434:                  * This function will yield the protothread, thereby allowing other
435:                  * processing to take place in the system.
436:                  *
437:                  * \param pt A pointer to the protothread control structure.
438:                  *
439:                  * \hideinitializer
440:                  */
441:                 #define PT_YIELD(pt)				\
442:                   do {						\
443:                     PT_YIELD_FLAG = 0;				\
444:                     LC_SET((pt)->lc);				\
445:                     if(PT_YIELD_FLAG == 0) {			\
446:                       return PT_YIELDED;			\
447:                     }						\
448:                   } while(0)
449:                 
450:                 /**
451:                  * \brief      Yield from the protothread until a condition occurs.
452:                  * \param pt   A pointer to the protothread control structure.
453:                  * \param cond The condition.
454:                  *
455:                  *             This function will yield the protothread, until the
456:                  *             specified condition evaluates to true.
457:                  *
458:                  *
459:                  * \hideinitializer
460:                  */
461:                 #define PT_YIELD_UNTIL(pt, cond)		\
462:                   do {						\
463:                     PT_YIELD_FLAG = 0;				\
464:                     LC_SET((pt)->lc);				\
465:                     if((PT_YIELD_FLAG == 0) || !(cond)) {	\
466:                       return PT_YIELDED;                        \
467:                     }						\
468:                   } while(0)
469:                 
470:                 /** @} */
471:                 
472:                 #endif /* __PT_H__ */
473:                 
474:                 #ifndef __PT_SEM_H__
475:                 #define __PT_SEM_H__
476:                 
477:                 //#include "pt.h"
478:                 
479:                 struct pt_sem {
480:                   unsigned int count;
481:                 };
482:                 
483:                 /**
484:                  * Initialize a semaphore
485:                  *
486:                  * This macro initializes a semaphore with a value for the
487:                  * counter. Internally, the semaphores use an "unsigned int" to
488:                  * represent the counter, and therefore the "count" argument should be
489:                  * within range of an unsigned int.
490:                  *
491:                  * \param s (struct pt_sem *) A pointer to the pt_sem struct
492:                  * representing the semaphore
493:                  *
494:                  * \param c (unsigned int) The initial count of the semaphore.
495:                  * \hide initializer
496:                  */
497:                 #define PT_SEM_INIT(s, c) (s)->count = c
498:                 
499:                 /**
500:                  * Wait for a semaphore
501:                  *
502:                  * This macro carries out the "wait" operation on the semaphore. The
503:                  * wait operation causes the protothread to block while the counter is
504:                  * zero. When the counter reaches a value larger than zero, the
505:                  * protothread will continue.
506:                  *
507:                  * \param pt (struct pt *) A pointer to the protothread (struct pt) in
508:                  * which the operation is executed.
509:                  *
510:                  * \param s (struct pt_sem *) A pointer to the pt_sem struct
511:                  * representing the semaphore
512:                  *
513:                  * \hideinitializer
514:                  */
515:                 #define PT_SEM_WAIT(pt, s)	\
516:                   do {						\
517:                     PT_WAIT_UNTIL(pt, (s)->count > 0);		\
518:                     --(s)->count;				\
519:                   } while(0)
520:                 
521:                 /**
522:                  * Signal a semaphore
523:                  *
524:                  * This macro carries out the "signal" operation on the semaphore. The
525:                  * signal operation increments the counter inside the semaphore, which
526:                  * eventually will cause waiting protothreads to continue executing.
527:                  *
528:                  * \param pt (struct pt *) A pointer to the protothread (struct pt) in
529:                  * which the operation is executed.
530:                  *
531:                  * \param s (struct pt_sem *) A pointer to the pt_sem struct
532:                  * representing the semaphore
533:                  *
534:                  * \hideinitializer
535:                  */
536:                 #define PT_SEM_SIGNAL(pt, s) ++(s)->count
537:                 
538:                 #endif /* __PT_SEM_H__ */
539:                 
540:                 //=====================================================================
541:                 //=== BRL4 additions for PIC 32 =======================================
542:                 //=====================================================================
543:                 
544:                 // macro to time a thread execution interveal in millisec
545:                 // max time 4000 sec
546:                 //#include <plib.h>
547:                 //#include <limits.h>
548:                 //#include "config.h"
549:                 
550:                 #define PT_YIELD_TIME_msec(delay_time)  \
551:                     do { static unsigned int time_thread ;\
552:                     time_thread = time_tick_millsec + (unsigned int)delay_time ; \
553:                     PT_YIELD_UNTIL(pt, (time_tick_millsec >= time_thread)); \
554:                     } while(0);
555:                 
556:                 // macro to return system time
557:                 #define PT_GET_TIME() (time_tick_millsec)
558:                 
559:                 // init rate sehcduler
560:                 //#define PT_INIT(pt, priority)   LC_INIT((pt)->lc ; (pt)->pri = priority)
561:                 //PT_PRIORITY_INIT
562:                 #define PT_RATE_INIT() int pt_pri_count = 0;
563:                 // maitain proority frame count
564:                 //PT_PRIORITY_LOOP maitains a counter used to control execution
565:                 #define PT_RATE_LOOP() pt_pri_count = (pt_pri_count+1) & 0xf ;
566:                 // schecedule priority thread
567:                 //PT_PRIORITY_SCHEDULE
568:                 // 5 levels
569:                 // rate 0 is highest -- every time thru loop
570:                 // priority 1 -- every 2 times thru loop
571:                 // priority 2 -- every 4 times thru loop
572:                 //  3 is  -- every 8 times thru loop
573:                 #define PT_RATE_SCHEDULE(f,rate) \
574:                     if((rate==0) | \
575:                     (rate==1 && ((pt_pri_count & 0b1)==0) ) | \
576:                     (rate==2 && ((pt_pri_count & 0b11)==0) ) | \
577:                     (rate==3 && ((pt_pri_count & 0b111)==0)) | \
578:                     (rate==4 && ((pt_pri_count & 0b1111)==0))) \
579:                         PT_SCHEDULE(f);
580:                 
581:                 // macro to use 4 bit DAC as debugger output
582:                 // level range 0-15; duration in microseconds
583:                 // -- with zero meaning HOLD it on forever
584:                 //while((signed int)ReadTimer45() <= time_hold){};
585:                 // time_hold = duration + ReadTimer45() ;
586:                 #define PT_DEBUG_VALUE(level, duration) \
587:                 do { static int i ; \
588:                     CVRCON = CVRCON_setup | (level & 0xf); \
589:                     if (duration>0){                   \
590:                         for (i=0; i<duration*7; i++){};\
591:                         CVRCON = CVRCON_setup; \
592:                     } \
593:                 } while(0);
594:                 
595:                 // macros to manipulate a semaphore without blocking
596:                 #define PT_SEM_SET(s) (s)->count=1
597:                 #define PT_SEM_CLEAR(s) (s)->count=0
598:                 #define PT_SEM_READ(s) (s)->count
599:                 #define PT_SEM_ACCEPT(s) \
600:                   s->count; \
601:                   if (s->count) s->count-- ; \
602:                 
603:                 //====================================================================
604:                 //=== serial setup ===================================================
605:                 //#ifdef use_uart_serial
606:                 ///////////////////////////
607:                 // UART parameters
608:                 
609:                 #define PB_DIVISOR (1 << OSCCONbits.PBDIV) // read the peripheral bus divider, FPBDIV
610:                 #define PB_FREQ sys_clock/PB_DIVISOR // periperhal bus frequency
611:                 #define clrscr() printf( "\x1b[2J")
612:                 #define home()   printf( "\x1b[H")
613:                 #define pcr()    printf( '\r')
614:                 #define crlf     putchar(0x0a); putchar(0x0d);
615:                 #define backspace 0x7f // make sure your backspace matches this!
616:                 #define max_chars 64 // for input/output buffer
617:                 //====================================================================
618:                 // build a string from the UART2 /////////////
619:                 //////////////////////////////////////////////
620:                 char PT_term_buffer[max_chars];
621:                 int num_char;
622:                 int PT_GetSerialBuffer(struct pt *pt)
623:                 {
624:                     static char character;
625:                     // mark the beginnning of the input thread
626:                     PT_BEGIN(pt);
9D001420  8C820000   LW V0, 0(A0)
9D001424  5040006C   BEQL V0, ZERO, 0x9D0015D8
9D001428  AF8080B4   SW ZERO, -32588(GP)
9D00142C  00400008   JR V0
9D001430  00000000   NOP
627:                 
628:                     num_char = 0;
629:                     //memset(term_buffer, 0, max_chars);
630:                 
631:                     while(num_char < max_chars)
9D0015B4  8F8280B4   LW V0, -32588(GP)
9D0015B8  28420040   SLTI V0, V0, 64
9D0015BC  54400007   BNEL V0, ZERO, 0x9D0015DC
9D0015C0  3C029D00   LUI V0, -25344
632:                     {
633:                         // get the character
634:                         // yield until there is a valid character so that other
635:                         // threads can execute
636:                         PT_YIELD_UNTIL(pt, UARTReceivedDataIsAvailable(UART2));
9D001434  3C029D00   LUI V0, -25344
9D001438  24421434   ADDIU V0, V0, 5172
9D00143C  AC820000   SW V0, 0(A0)
9D001450  10A00069   BEQ A1, ZERO, 0x9D0015F8
9D001454  24020001   ADDIU V0, ZERO, 1
9D0015D8  3C029D00   LUI V0, -25344
9D0015DC  24421434   ADDIU V0, V0, 5172
9D0015E0  AC820000   SW V0, 0(A0)
9D0015E4  03E00008   JR RA
9D0015E8  24020001   ADDIU V0, ZERO, 1
637:                        // while(!UARTReceivedDataIsAvailable(UART2)){};
638:                         character = UARTGetDataByte(UART2);
9D00145C  A3828068   SB V0, -32664(GP)
639:                         PT_YIELD_UNTIL(pt, UARTTransmitterIsReady(UART2));
9D001460  3C029D00   LUI V0, -25344
9D001464  24421474   ADDIU V0, V0, 5236
9D001468  AC820000   SW V0, 0(A0)
9D00146C  03E00008   JR RA
9D001470  24020001   ADDIU V0, ZERO, 1
9D001474  3C029D00   LUI V0, -25344
9D001478  24421474   ADDIU V0, V0, 5236
9D00147C  AC820000   SW V0, 0(A0)
9D001490  14A00059   BNE A1, ZERO, 0x9D0015F8
9D001494  24020001   ADDIU V0, ZERO, 1
640:                         UARTSendDataByte(UART2, character);
9D001498  83828068   LB V0, -32664(GP)
641:                 
642:                         // unomment to check backspace character!!!
643:                         //printf("--%x--",character );
644:                 
645:                         // end line
646:                         if(character == '\r'){
9D0014A4  2403000D   ADDIU V1, ZERO, 13
9D0014A8  14430017   BNE V0, V1, 0x9D001508
9D0014AC  2403007F   ADDIU V1, ZERO, 127
647:                             PT_term_buffer[num_char] = 0; // zero terminate the string
9D0014B0  3C02A000   LUI V0, -24576
9D0014B4  244203FC   ADDIU V0, V0, 1020
9D0014B8  8F8380B4   LW V1, -32588(GP)
9D0014BC  00621021   ADDU V0, V1, V0
9D0014C0  A0400000   SB ZERO, 0(V0)
648:                             //crlf; // send a new line
649:                             PT_YIELD_UNTIL(pt, UARTTransmitterIsReady(UART2));
9D0014C4  3C029D00   LUI V0, -25344
9D0014C8  244214D8   ADDIU V0, V0, 5336
9D0014CC  AC820000   SW V0, 0(A0)
9D0014D0  03E00008   JR RA
9D0014D4  24020001   ADDIU V0, ZERO, 1
9D0014D8  3C029D00   LUI V0, -25344
9D0014DC  244214D8   ADDIU V0, V0, 5336
9D0014E0  AC820000   SW V0, 0(A0)
9D0014F4  14600036   BNE V1, ZERO, 0x9D0015D0
9D0014F8  2403000A   ADDIU V1, ZERO, 10
9D0015D0  03E00008   JR RA
9D0015D4  24020001   ADDIU V0, ZERO, 1
650:                             UARTSendDataByte(UART2, '\n');
651:                             break;
652:                         }
653:                         // backspace
654:                         else if (character == backspace){
9D001508  14430024   BNE V0, V1, 0x9D00159C
9D00150C  8F8380B4   LW V1, -32588(GP)
9D001510  0B40057B   J 0x9D0015EC
9D001514  3C029D00   LUI V0, -25344
655:                             PT_YIELD_UNTIL(pt, UARTTransmitterIsReady(UART2));
9D001518  3C029D00   LUI V0, -25344
9D00151C  24421518   ADDIU V0, V0, 5400
9D001520  AC820000   SW V0, 0(A0)
9D001534  14A00030   BNE A1, ZERO, 0x9D0015F8
9D001538  24020001   ADDIU V0, ZERO, 1
9D0015EC  24421518   ADDIU V0, V0, 5400
9D0015F0  AC820000   SW V0, 0(A0)
9D0015F4  24020001   ADDIU V0, ZERO, 1
656:                             UARTSendDataByte(UART2, ' ');
657:                             PT_YIELD_UNTIL(pt, UARTTransmitterIsReady(UART2));
9D001544  3C029D00   LUI V0, -25344
9D001548  24421558   ADDIU V0, V0, 5464
9D00154C  AC820000   SW V0, 0(A0)
9D001550  03E00008   JR RA
9D001554  24020001   ADDIU V0, ZERO, 1
9D001558  3C029D00   LUI V0, -25344
9D00155C  24421558   ADDIU V0, V0, 5464
9D001560  AC820000   SW V0, 0(A0)
9D001574  14A00020   BNE A1, ZERO, 0x9D0015F8
9D001578  24020001   ADDIU V0, ZERO, 1
658:                             UARTSendDataByte(UART2, backspace);
659:                             num_char--;
9D001584  8F8280B4   LW V0, -32588(GP)
9D001588  2442FFFF   ADDIU V0, V0, -1
9D001594  0B40056D   J 0x9D0015B4
9D001598  AF8280B4   SW V0, -32588(GP)
660:                             // check for buffer underflow
661:                             if (num_char<0) {num_char = 0 ;}
9D00158C  04420012   BLTZL V0, 0x9D0015D8
9D001590  AF8080B4   SW ZERO, -32588(GP)
662:                         }
663:                         else  {PT_term_buffer[num_char++] = character ;}
9D00159C  24650001   ADDIU A1, V1, 1
9D0015A0  AF8580B4   SW A1, -32588(GP)
9D0015A4  3C05A000   LUI A1, -24576
9D0015A8  24A503FC   ADDIU A1, A1, 1020
9D0015AC  00651821   ADDU V1, V1, A1
9D0015B0  A0620000   SB V0, 0(V1)
664:                          //if (character == backspace)
665:                 
666:                     } //end while(num_char < max_size)
667:                 
668:                     // kill this input thread, to allow spawning thread to execute
669:                     PT_EXIT(pt);
9D001500  0B400572   J 0x9D0015C8
9D001504  AC800000   SW ZERO, 0(A0)
9D0015C4  AC800000   SW ZERO, 0(A0)
9D0015C8  03E00008   JR RA
9D0015CC  24020002   ADDIU V0, ZERO, 2
670:                     // and indicate the end of the thread
671:                     PT_END(pt);
672:                 }
9D0015F8  03E00008   JR RA
9D0015FC  00000000   NOP
673:                 
674:                 //====================================================================
675:                 // === send a string to the UART2 ====================================
676:                 char PT_send_buffer[max_chars];
677:                 int num_send_chars ;
678:                 int PutSerialBuffer(struct pt *pt)
679:                 {
680:                     PT_BEGIN(pt);
9D001600  8C820000   LW V0, 0(A0)
9D001604  14400003   BNE V0, ZERO, 0x9D001614
9D001608  3C029D00   LUI V0, -25344
681:                     num_send_chars = 0;
682:                     while (PT_send_buffer[num_send_chars] != 0){
9D00160C  0B400595   J 0x9D001654
9D001610  AF80809C   SW ZERO, -32612(GP)
9D001654  3C02A000   LUI V0, -24576
9D001658  244200D8   ADDIU V0, V0, 216
9D00165C  8F83809C   LW V1, -32612(GP)
9D001660  00621021   ADDU V0, V1, V0
9D001664  80420000   LB V0, 0(V0)
9D001668  54400004   BNEL V0, ZERO, 0x9D00167C
9D00166C  3C029D00   LUI V0, -25344
683:                         PT_YIELD_UNTIL(pt, UARTTransmitterIsReady(UART2));
9D001614  24421614   ADDIU V0, V0, 5652
9D001618  AC820000   SW V0, 0(A0)
9D00162C  14A00016   BNE A1, ZERO, 0x9D001688
9D001630  24020001   ADDIU V0, ZERO, 1
9D00167C  24421614   ADDIU V0, V0, 5652
9D001680  AC820000   SW V0, 0(A0)
9D001684  24020001   ADDIU V0, ZERO, 1
684:                         UARTSendDataByte(UART2, PT_send_buffer[num_send_chars]);
9D001634  8F82809C   LW V0, -32612(GP)
9D001638  3C05A000   LUI A1, -24576
9D00163C  24A500D8   ADDIU A1, A1, 216
9D001640  00452821   ADDU A1, V0, A1
685:                         num_send_chars++;
9D00164C  24420001   ADDIU V0, V0, 1
9D001650  AF82809C   SW V0, -32612(GP)
686:                     }
687:                     // kill this output thread, to allow spawning thread to execute
688:                     PT_EXIT(pt);
9D001670  AC800000   SW ZERO, 0(A0)
9D001674  03E00008   JR RA
9D001678  24020002   ADDIU V0, ZERO, 2
689:                     // and indicate the end of the thread
690:                     PT_END(pt);
691:                 }
9D001688  03E00008   JR RA
9D00168C  00000000   NOP
692:                 
693:                 //====================================================================
694:                 // === DMA send string to the UART2 ==================================
695:                 int PT_DMA_PutSerialBuffer(struct pt *pt)
696:                 {
9D001690  27BDFFE8   ADDIU SP, SP, -24
9D001694  AFBF0014   SW RA, 20(SP)
9D001698  AFB00010   SW S0, 16(SP)
697:                     PT_BEGIN(pt);
9D00169C  8C820000   LW V0, 0(A0)
9D0016A0  10400003   BEQ V0, ZERO, 0x9D0016B0
9D0016A4  00808021   ADDU S0, A0, ZERO
9D0016A8  00400008   JR V0
9D0016AC  00000000   NOP
698:                     //mPORTBSetBits(BIT_0);
699:                     // check for null string
700:                     if (PT_send_buffer[0]==0)PT_EXIT(pt);
9D0016B0  3C02A000   LUI V0, -24576
9D0016B4  804300D8   LB V1, 216(V0)
9D0016B8  10600033   BEQ V1, ZERO, 0x9D001788
9D0016BC  24020002   ADDIU V0, ZERO, 2
9D0016C0  0B4005DA   J 0x9D001768
9D0016C4  3C029D00   LUI V0, -25344
701:                     // sent the first character
702:                     PT_YIELD_UNTIL(pt, UARTTransmitterIsReady(UART2));
9D0016C8  3C029D00   LUI V0, -25344
9D0016CC  244216C8   ADDIU V0, V0, 5832
9D0016D0  AC820000   SW V0, 0(A0)
9D0016E4  14800028   BNE A0, ZERO, 0x9D001788
9D0016E8  24020001   ADDIU V0, ZERO, 1
9D001768  244216C8   ADDIU V0, V0, 5832
9D00176C  AC820000   SW V0, 0(A0)
9D001770  0B4005E2   J 0x9D001788
9D001774  24020001   ADDIU V0, ZERO, 1
703:                     UARTSendDataByte(UART2, PT_send_buffer[0]);
9D0016EC  3C02A000   LUI V0, -24576
704:                     //DmaChnStartTxfer(DMA_CHANNEL1, DMA_WAIT_NOT, 0);
705:                     // start the DMA
706:                     DmaChnEnable(DMA_CHANNEL1);
9D0016F8  0F401FA6   JAL DmaChnEnable
9D0016FC  24040001   ADDIU A0, ZERO, 1
707:                     // wait for DMA done
708:                     //mPORTBClearBits(BIT_0);
709:                     PT_YIELD_UNTIL(pt, DmaChnGetEvFlags(DMA_CHANNEL1) & DMA_EV_BLOCK_DONE);
9D001700  3C029D00   LUI V0, -25344
9D001704  24421714   ADDIU V0, V0, 5908
9D001708  AE020000   SW V0, 0(S0)
9D00170C  0B4005E2   J 0x9D001788
9D001710  24020001   ADDIU V0, ZERO, 1
9D001714  3C029D00   LUI V0, -25344
9D001718  24421714   ADDIU V0, V0, 5908
9D00171C  AC820000   SW V0, 0(A0)
9D001720  0F401FCE   JAL DmaChnGetEvFlags
9D001724  24040001   ADDIU A0, ZERO, 1
9D001728  30430008   ANDI V1, V0, 8
9D00172C  14600012   BNE V1, ZERO, 0x9D001778
9D001730  24020001   ADDIU V0, ZERO, 1
9D001734  0B4005E3   J 0x9D00178C
9D001738  8FBF0014   LW RA, 20(SP)
710:                     //wait until the transmit buffer is empty
711:                     PT_YIELD_UNTIL(pt, U2STA&0x100);
9D00173C  3C029D00   LUI V0, -25344
9D001740  2442173C   ADDIU V0, V0, 5948
9D001744  AC820000   SW V0, 0(A0)
9D001748  3C02BF80   LUI V0, -16512
9D00174C  8C426210   LW V0, 25104(V0)
9D001750  30420100   ANDI V0, V0, 256
9D001754  5040000C   BEQL V0, ZERO, 0x9D001788
9D001758  24020001   ADDIU V0, ZERO, 1
9D001778  3C029D00   LUI V0, -25344
9D00177C  2442173C   ADDIU V0, V0, 5948
9D001780  AE020000   SW V0, 0(S0)
9D001784  24020001   ADDIU V0, ZERO, 1
712:                     
713:                     // kill this output thread, to allow spawning thread to execute
714:                     PT_EXIT(pt);
9D00175C  AC800000   SW ZERO, 0(A0)
9D001760  0B4005E2   J 0x9D001788
9D001764  24020002   ADDIU V0, ZERO, 2
715:                     // and indicate the end of the thread
716:                     PT_END(pt);
717:                 }
9D001788  8FBF0014   LW RA, 20(SP)
9D00178C  8FB00010   LW S0, 16(SP)
9D001790  03E00008   JR RA
9D001794  27BD0018   ADDIU SP, SP, 24
718:                 //#endif //#ifdef use_uart_serial
719:                 
720:                 //======================================================================
721:                 // vref confing (if used)
722:                 int CVRCON_setup ;
723:                 
724:                 // system time
725:                 volatile unsigned int time_tick_millsec ;
726:                 // force full context save
727:                 //int w;
728:                 //void waste(void){w=1;};
729:                 // Timer 5 interrupt handler ///////
730:                 // ipl2 means "interrupt priority level 2"
731:                 void __ISR(_TIMER_5_VECTOR, IPL2AUTO) Timer5Handler(void) //_TIMER_5_VECTOR
732:                 {
9D001798  415DE800   RDPGPR SP, SP
9D00179C  401B7000   MFC0 K1, EPC
9D0017A0  401A6002   MFC0 K0, SRSCtl
9D0017A4  27BDFFE8   ADDIU SP, SP, -24
9D0017A8  AFBB0014   SW K1, 20(SP)
9D0017AC  401B6000   MFC0 K1, Status
9D0017B0  AFBA000C   SW K0, 12(SP)
9D0017B4  AFBB0010   SW K1, 16(SP)
9D0017B8  7C1B7844   INS K1, ZERO, 1, 15
9D0017BC  377B0800   ORI K1, K1, 2048
9D0017C0  409B6000   MTC0 K1, Status
9D0017C4  AFA30004   SW V1, 4(SP)
9D0017C8  AFA20000   SW V0, 0(SP)
733:                     // clear the interrupt flag
734:                     mT5ClearIntFlag();
9D0017CC  3C030100   LUI V1, 256
9D0017D0  3C02BF88   LUI V0, -16504
9D0017D4  AC431034   SW V1, 4148(V0)
735:                     //count milliseconds
736:                     time_tick_millsec++ ;
9D0017D8  8F8280B0   LW V0, -32592(GP)
9D0017DC  24420001   ADDIU V0, V0, 1
9D0017E0  AF8280B0   SW V0, -32592(GP)
737:                     //waste();
738:                 }
9D0017E4  8FA2000C   LW V0, 12(SP)
9D0017E8  3042000F   ANDI V0, V0, 15
9D0017EC  14400003   BNE V0, ZERO, 0x9D0017FC
9D0017F0  00000000   NOP
9D0017F4  8FA30004   LW V1, 4(SP)
9D0017F8  8FA20000   LW V0, 0(SP)
9D0017FC  41606000   DI ZERO
9D001800  000000C0   EHB
9D001804  8FBA0014   LW K0, 20(SP)
9D001808  8FBB0010   LW K1, 16(SP)
9D00180C  409A7000   MTC0 K0, EPC
9D001810  8FBA000C   LW K0, 12(SP)
9D001814  27BD0018   ADDIU SP, SP, 24
9D001818  409A6002   MTC0 K0, SRSCtl
9D00181C  41DDE800   WRPGPR SP, SP
9D001820  409B6000   MTC0 K1, Status
9D001824  42000018   ERET
739:                 
740:                 void PT_setup (void)
741:                 {
9D001828  27BDFFE0   ADDIU SP, SP, -32
9D00182C  AFBF001C   SW RA, 28(SP)
742:                   // Configure the device for maximum performance but do not change the PBDIV
743:                     // Given the options, this function will change the flash wait states, RAM
744:                     // wait state and enable prefetch cache but will not change the PBDIV.
745:                     // The PBDIV value is already set via the pragma FPBDIV option above..
746:                     SYSTEMConfig(sys_clock, SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
747:                 
748:                   ANSELA =0; //make sure analog is cleared
9D001854  3C02BF88   LUI V0, -16504
9D001858  AC406000   SW ZERO, 24576(V0)
749:                   ANSELB =0;
9D00185C  3C02BF88   LUI V0, -16504
9D001860  AC406100   SW ZERO, 24832(V0)
750:                   
751:                 #ifdef use_uart_serial
752:                   // === init the uart2 ===================
753:                  PPSInput (2, U2RX, RPB11); //Assign U2RX to pin RPB11 -- Physical pin 22 on 28 PDIP
9D001864  3C02BF81   LUI V0, -16511
9D001868  9043FA58   LBU V1, -1448(V0)
9D00186C  24100003   ADDIU S0, ZERO, 3
9D001870  7E031804   INS V1, S0, 0, 4
9D001874  A043FA58   SB V1, -1448(V0)
754:                  PPSOutput(4, RPB10, U2TX); //Assign U2TX to pin RPB10 -- Physical pin 21 on 28 PDIP
9D001878  3C02BF81   LUI V0, -16511
9D00187C  9043FB54   LBU V1, -1196(V0)
9D001880  24040002   ADDIU A0, ZERO, 2
9D001884  7C831804   INS V1, A0, 0, 4
9D001888  A043FB54   SB V1, -1196(V0)
755:                   UARTConfigure(UART2, UART_ENABLE_PINS_TX_RX_ONLY);
9D00188C  24040001   ADDIU A0, ZERO, 1
9D001890  0F401F05   JAL UARTConfigure
9D001894  00002821   ADDU A1, ZERO, ZERO
756:                   UARTSetLineControl(UART2, UART_DATA_SIZE_8_BITS | UART_PARITY_NONE | UART_STOP_BITS_1);
9D001898  24040001   ADDIU A0, ZERO, 1
9D00189C  0F401FBA   JAL UARTSetLineControl
9D0018A0  00002821   ADDU A1, ZERO, ZERO
757:                   UARTSetDataRate(UART2, pb_clock, BAUDRATE);
9D0018A4  24040001   ADDIU A0, ZERO, 1
9D0018A8  3C0501C9   LUI A1, 457
9D0018AC  34A5C380   ORI A1, A1, -15488
9D0018B0  0F401DF8   JAL UARTSetDataRate
9D0018B4  24062580   ADDIU A2, ZERO, 9600
758:                   UARTEnable(UART2, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
9D0018B8  24040001   ADDIU A0, ZERO, 1
9D0018BC  0F401CFA   JAL UARTEnable
9D0018C0  24050087   ADDIU A1, ZERO, 135
759:                   printf("\n\r..protothreads start..\n\r");
9D0018C4  3C049D00   LUI A0, -25344
9D0018C8  0F401ED5   JAL _printf_s
9D0018CC  24846F2C   ADDIU A0, A0, 28460
760:                   // === set up DMA for UART output =========
761:                   // configure the channel and enable end-on-match
762:                   DmaChnOpen(DMA_CHANNEL1, DMA_CHN_PRI2, DMA_OPEN_MATCH);
9D0018D0  24040001   ADDIU A0, ZERO, 1
9D0018D4  24050002   ADDIU A1, ZERO, 2
9D0018D8  0F401A6B   JAL DmaChnOpen
9D0018DC  3C068000   LUI A2, -32768
763:                   // trigger a byte everytime the UART is empty
764:                   DmaChnSetEventControl(DMA_CHANNEL1, DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_TX_IRQ));
9D0018E0  24040001   ADDIU A0, ZERO, 1
9D0018E4  0F401F4C   JAL DmaChnWriteEventControlFlags
9D0018E8  24053730   ADDIU A1, ZERO, 14128
765:                   // source and destination
766:                   DmaChnSetTxfer(DMA_CHANNEL1, PT_send_buffer+1, (void*)&U2TXREG, max_chars, 1, 1);
9D0018EC  24020001   ADDIU V0, ZERO, 1
9D0018F0  AFA20010   SW V0, 16(SP)
9D0018F4  AFA20014   SW V0, 20(SP)
9D0018F8  24040001   ADDIU A0, ZERO, 1
9D0018FC  3C05A000   LUI A1, -24576
9D001900  24A500D9   ADDIU A1, A1, 217
9D001904  3C06BF80   LUI A2, -16512
9D001908  24C66220   ADDIU A2, A2, 25120
9D00190C  0F401C1C   JAL DmaChnSetTxfer
9D001910  24070040   ADDIU A3, ZERO, 64
767:                   // signal when done
768:                   DmaChnSetEvEnableFlags(DMA_CHANNEL1, DMA_EV_BLOCK_DONE);
9D001914  24040001   ADDIU A0, ZERO, 1
9D001918  0F401F9C   JAL DmaChnSetEvEnableFlags
9D00191C  24050008   ADDIU A1, ZERO, 8
769:                   // set null as ending character (of a string)
770:                   DmaChnSetMatchPattern(DMA_CHANNEL1, 0x00);
9D001920  24040001   ADDIU A0, ZERO, 1
9D001924  0F401FD7   JAL DmaChnSetMatchPattern
9D001928  00002821   ADDU A1, ZERO, ZERO
771:                 #endif //#ifdef use_uart_serial
772:                   
773:                   // ===Set up timer5 ======================
774:                   // timer 5: on,  interrupts, internal clock, 
775:                   // set up to count millsec
776:                   OpenTimer5(T5_ON  | T5_SOURCE_INT | T5_PS_1_1 , pb_clock/1000);
9D00192C  3C02BF80   LUI V0, -16512
9D001930  AC400E00   SW ZERO, 3584(V0)
9D001934  3C02BF80   LUI V0, -16512
9D001938  AC400E10   SW ZERO, 3600(V0)
9D00193C  24037530   ADDIU V1, ZERO, 30000
9D001940  3C02BF80   LUI V0, -16512
9D001944  AC430E20   SW V1, 3616(V0)
9D001948  34038000   ORI V1, ZERO, -32768
9D00194C  3C02BF80   LUI V0, -16512
9D001950  AC430E08   SW V1, 3592(V0)
777:                   // set up the timer interrupt with a priority of 2
778:                   ConfigIntTimer5(T5_INT_ON | T5_INT_PRIOR_2);
9D001954  3C03BF88   LUI V1, -16504
9D001958  3C020100   LUI V0, 256
9D00195C  AC621034   SW V0, 4148(V1)
9D001960  3C05BF88   LUI A1, -16504
9D001964  2404001C   ADDIU A0, ZERO, 28
9D001968  ACA410E4   SW A0, 4324(A1)
9D00196C  3C04BF88   LUI A0, -16504
9D001970  24060008   ADDIU A2, ZERO, 8
9D001974  AC8610E8   SW A2, 4328(A0)
9D001978  ACB010E4   SW S0, 4324(A1)
9D00197C  AC8010E8   SW ZERO, 4328(A0)
9D001980  3C04BF88   LUI A0, -16504
9D001984  AC821064   SW V0, 4196(A0)
9D001988  3C04BF88   LUI A0, -16504
9D00198C  AC821068   SW V0, 4200(A0)
779:                   mT5ClearIntFlag(); // and clear the interrupt flag
9D001990  AC621034   SW V0, 4148(V1)
780:                   // zero the system time tick
781:                   time_tick_millsec = 0;
9D001994  AF8080B0   SW ZERO, -32592(GP)
782:                 
783:                   //=== Set up VREF as a debugger output =======
784:                   #ifdef use_vref_debug
785:                   // set up the Vref pin and use as a DAC
786:                   // enable module| eanble output | use low range output | use internal reference | desired step
787:                   CVREFOpen( CVREF_ENABLE | CVREF_OUTPUT_ENABLE | CVREF_RANGE_LOW | CVREF_SOURCE_AVDD | CVREF_STEP_0 );
788:                   // And read back setup from CVRCON for speed later
789:                   // 0x8060 is enabled with output enabled, Vdd ref, and 0-0.6(Vdd) range
790:                   CVRCON_setup = CVRCON; //CVRCON = 0x8060 from Tahmid http://tahmidmc.blogspot.com/
791:                 
792:                 #endif //#ifdef use_vref_debug
793:                 
794:                 }
9D001998  8FBF001C   LW RA, 28(SP)
9D00199C  8FB00018   LW S0, 24(SP)
9D0019A0  03E00008   JR RA
9D0019A4  27BD0020   ADDIU SP, SP, 32
---  z:/eedocs/4760/pic/neural_model_pt_1_2/neuron_dac_adc_4.c  -----------------------------------------
1:                   /*********************************************************************
2:                    *  Izhikevich neurons
3:                    *  SPI to  MCP4822 dual channel 12-bit DAC output
4:                    *  read 2 channels of ADC for input
5:                    *  Time step 
6:                    *********************************************************************
7:                    * Bruce Land Cornell University
8:                    * Oct 2016
9:                    *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
10:                  */
11:                  /* ====== MCP4822 control word ==============
12:                  bit 15 A/B: DACA or DACB Selection bit
13:                  1 = Write to DACB
14:                  0 = Write to DACA
15:                  bit 14 ? Don?t Care
16:                  bit 13 GA: Output Gain Selection bit
17:                  1 = 1x (VOUT = VREF * D/4096)
18:                  0 = 2x (VOUT = 2 * VREF * D/4096), where internal VREF = 2.048V.
19:                  bit 12 SHDN: Output Shutdown Control bit
20:                  1 = Active mode operation. VOUT is available. ?
21:                  0 = Shutdown the selected DAC channel. Analog output is not available at the channel that was shut down.
22:                  VOUT pin is connected to 500 k???typical)?
23:                  bit 11-0 D11:D0: DAC Input Data bits. Bit x is ignored.
24:                  */
25:                  // A-channel, 1x, active
26:                  #define DAC_config_chan_A 0b0011000000000000
27:                  #define DAC_config_chan_B 0b1011000000000000
28:                  #define two32 4294967296.0 // 2^32 
29:                  
30:                  ////////////////////////////////////
31:                  // clock AND protoThreads configure!
32:                  // You MUST check this file!
33:                  #include "config.h"
34:                  // threading library
35:                  #include "pt_cornell_1_2_1.h"
36:                  // for rand()
37:                  #include <stdlib.h>
38:                  volatile SpiChannel spiChn = SPI_CHANNEL2 ;	// the SPI channel to use
39:                  // for 60 MHz PB clock use divide-by-3
40:                  volatile int spiClkDiv = 2 ; // 15 MHz DAC clock
41:                  
42:                  // === thread structures ============================================
43:                  // thread control structs
44:                  // note that UART input and output are threads
45:                  static struct pt pt_cmd, pt_tick, pt_Izhikevich, pt_environment ;
46:                  // uart control threads
47:                  static struct pt pt_input, pt_output, pt_DMA_output ;
48:                  
49:                  // system 1 second interval tick
50:                  int sys_time_seconds ;
51:                  
52:                  // ===================================================================
53:                  // == 2:14 bit fixed point 2.14 format ===============================
54:                  // ===================================================================
55:                  // resolution 2^-14 =  6.1035e-5
56:                  // dynamic range is +1.9999/-2.0
57:                  typedef signed short fix14 ;
58:                  #define multfix14(a,b) ((fix14)((((int)(a))*((int)(b)))>>14)) //multiply two fixed 2.14
59:                  #define float2fix14(a) ((fix14)((a)*16384.0)) // 2^14
60:                  #define fix2float14(a) ((float)(a)/16384.0)
61:                  // convert 14 bit to 12 bit and convert 2's comp to offset
62:                  #define fix2dac14(a)   ((int)((a)>>4)+2048)  
63:                  // #define fix2int14(a)    ((int)((a)>>14)) define ALL numbers as less than +/-1!
64:                  // #define int2fix14(a)    ((fix8)((a)<<14)) define ALL numbers as less than +/-1!
65:                  #define absfix14(a) abs(a)
66:                  #define shiftfix14(a,b) ((fix14)((int)(a)>>(int)(b)))
67:                  // generate a uniform random number between -a and +a
68:                  // NOTE: 0<a<1 range limit!
69:                  #define randfix14(a) float2fix14((-1+2*((float)rand())/RAND_MAX) * a) ;
70:                  //======================================================================
71:                  // the neurons and parameters
72:                  // n_neuron=18 is 4300 fps with learning turned ON
73:                  // n_neuron=30 is 5200 fps with learning turned OFF
74:                  #define n_neuron 10
75:                  #define v_init float2fix14(-0.65)
76:                  //================
77:                  // Izhikevich type3 neuron parameters (see bottom of program)
78:                  #define a_type3 6
79:                  #define b_type3 2
80:                  #define c_type3 float2fix14(-0.5)
81:                  #define d_type3 float2fix14(0.02)
82:                  #define Is_type3 float2fix14(0.15) //0.15
83:                  //================
84:                  // type 2 phasic spiking
85:                  #define a_type2 6
86:                  #define b_type2 2
87:                  #define c_type2 float2fix14(-0.65)
88:                  #define d_type2 float2fix14(0.06)
89:                  #define Is_type2 float2fix14(0.005) //0.15
90:                  //================
91:                  // regular spiking
92:                  #define a_type_reg 6
93:                  #define b_type_reg 2
94:                  #define c_type_reg float2fix14(-0.65)
95:                  #define d_type_reg float2fix14(0.08)
96:                  #define Is_type_reg float2fix14(0.001) //0.15
97:                  //================
98:                  // parameter arrays
99:                  fix14 v[n_neuron];
100:                 fix14 u[n_neuron];
101:                 fix14 a[n_neuron];
102:                 fix14 b[n_neuron];
103:                 fix14 c[n_neuron];
104:                 fix14 d[n_neuron];
105:                 fix14 Is[n_neuron];
106:                 // Is plus environment current 
107:                 fix14 Is_total[n_neuron];
108:                 // reset value
109:                 fix14 u_reset[n_neuron];
110:                 // boolean for spike occur
111:                 char spike[n_neuron];
112:                 // spike counter for output averaging
113:                 int cum_spike[n_neuron];
114:                 // constant 1.4 divided by 4
115:                 fix14 c14 = float2fix14(1.4/4) ;
116:                 //fix14 c54 = float2fix14(5.0/4.0) ;
117:                 // define AP peak value
118:                 fix14 peak = float2fix14(0.3) ;
119:                 // time step shift
120:                 // for dt=1/16; dt_shift=4 and dt_shift_minus2=2
121:                 // Need this because scaling required a divide by 4
122:                 #define dt_shift 4
123:                 #define dt_shift_minus2 2
124:                 
125:                 //  now the synaptic weights
126:                 // total synaptic current
127:                 fix14 I_syn[n_neuron];
128:                 // first index is presyn, second is postsyn neuron 
129:                 fix14 w_syn[n_neuron][n_neuron] ;
130:                 // current positive delta weight for STDP
131:                 fix14 weight_plus[n_neuron][n_neuron] ;
132:                 // current positive delta weight for STDP
133:                 fix14 weight_minus[n_neuron][n_neuron] ;
134:                 // synaptic weight max positive weight change
135:                 fix14 d_weight_plus = float2fix14(0.0001) ;
136:                 // synaptic weight max negative weight change
137:                 // MUST be bigger than pos weight
138:                 fix14 d_weight_minus = float2fix14(0.001) ;
139:                 // max under any condition
140:                 fix14 max_weight = float2fix14(0.05) ;
141:                 // 2^4 time step time constant for STDP at 4/mSec = 4 mSec
142:                 // probably should be around 10-20 mSec
143:                 #define tau_stdp_plus 4
144:                 #define tau_stdp_minus 8
145:                 //========================
146:                 // Allow STDP learning?
147:                 // Define "learning"
148:                 //#define learning
149:                 //========================
150:                 
151:                 // display variables
152:                 // DAC voltage output routing
153:                 int DAC_A_source=0, DAC_B_source=1 ;
154:                 // frame rate computation
155:                 int compute_counter, fps;
156:                 
157:                 //== Timer 2 interrupt handler ===========================================
158:                 // actual scaled DAC 
159:                 volatile  int DAC_data, quadrature_data;
160:                 // ADC output
161:                 volatile  int ADC_net;	// conversion result as read from result buffer
162:                 // the DDS units:
163:                 
164:                 //=============================
165:                 //void __ISR(_TIMER_2_VECTOR, ipl2) Timer2Handler(void)
166:                 //{
167:                     // 74 cycles to get to this point from timer event
168:                    //mT2ClearIntFlag();
169:                     
170:                     
171:                     // === Channel A =============
172:                     // CS low to start transaction
173:                      //mPORTBClearBits(BIT_0); // start transaction
174:                     // test for ready
175:                      //while (TxBufFullSPI2());
176:                     // write to spi2 
177:                     //WriteSPI2( DAC_config_chan_A | (DAC_data + 2048));
178:                     // end SPI transaction from last interrupt cycle
179:                     //mPORTBSetBits(BIT_0); 
180:                  
181:                     // main DDS phase
182:                     //phase_accum_main += phase_incr_main  ;
183:                     //sine_index = phase_accum_main>>24 ;
184:                     //DAC_data = cos_table[phase_accum_main>>24]  ;
185:                     // now the 90 degree data
186:                     //quadrature_data = sin_table[phase_accum_main>>24];
187:                     // read the result of channel 4 conversion from the idle buffer
188:                     // since we are reading 10 bit integer, we can treat this as a
189:                     // integer < 2^20 by shifting 10 bits
190:                     //ADC_net = (ReadADC10(0)<<10) ; // max value 2^20
191:                     //AcquireADC10(); // not needed if ADC_AUTO_SAMPLING_ON below
192:                     
193:                      //isr_time = ReadTimer2() ; // - isr_time;
194:                      
195:                 //} // end ISR TIMER2
196:                 
197:                 // === Serial Thread ======================================================
198:                 static PT_THREAD (protothread_cmd(struct pt *pt))
199:                 {
9D0019A8  27BDFFD8   ADDIU SP, SP, -40
9D0019AC  AFBF0024   SW RA, 36(SP)
9D0019B0  AFB20020   SW S2, 32(SP)
9D0019B4  AFB1001C   SW S1, 28(SP)
9D0019B8  AFB00018   SW S0, 24(SP)
200:                     // The serial interface
201:                     static char cmd[32];
202:                     static int iv1, iv2, iv3 ;
203:                     static float fv1, fv2, fv3 ;
204:                     
205:                     PT_BEGIN(pt);
9D0019BC  8C820000   LW V0, 0(A0)
9D0019C0  10400003   BEQ V0, ZERO, 0x9D0019D0
9D0019C4  00808021   ADDU S0, A0, ZERO
9D0019C8  00400008   JR V0
9D0019CC  00000000   NOP
206:                     
207:                     // clear port used by thread 4
208:                     // mPORTBClearBits(BIT_0);
209:                     
210:                       while(1) {
211:                           
212:                             // send the prompt via DMA to serial
213:                             sprintf(PT_send_buffer,"cmd>");
9D0019D0  3C02A000   LUI V0, -24576
9D0019D4  3C033E64   LUI V1, 15972
9D0019D8  24636D63   ADDIU V1, V1, 28003
9D0019DC  AC4300D8   SW V1, 216(V0)
9D0019E0  244200D8   ADDIU V0, V0, 216
9D0019E4  A0400004   SB ZERO, 4(V0)
214:                             // by spawning a print thread
215:                             PT_SPAWN(pt, &pt_DMA_output, PT_DMA_PutSerialBuffer(&pt_DMA_output) );
9D0019E8  AF80805C   SW ZERO, -32676(GP)
9D0019EC  3C029D00   LUI V0, -25344
9D0019F0  244219EC   ADDIU V0, V0, 6636
9D0019F4  AE020000   SW V0, 0(S0)
9D0019F8  0F4005A4   JAL PT_DMA_PutSerialBuffer
9D0019FC  2784805C   ADDIU A0, GP, -32676
9D001A00  28420002   SLTI V0, V0, 2
9D001A04  14400150   BNE V0, ZERO, 0x9D001F48
9D001A08  00001021   ADDU V0, ZERO, ZERO
216:                  
217:                           //spawn a thread to handle terminal input
218:                             // the input thread waits for input
219:                             // -- BUT does NOT block other threads
220:                             // string is returned in "PT_term_buffer"
221:                             PT_SPAWN(pt, &pt_input, PT_GetSerialBuffer(&pt_input) );
9D001A0C  AF80804C   SW ZERO, -32692(GP)
9D001A10  3C029D00   LUI V0, -25344
9D001A14  24421A10   ADDIU V0, V0, 6672
9D001A18  AE020000   SW V0, 0(S0)
9D001A1C  0F400508   JAL PT_GetSerialBuffer
9D001A20  2784804C   ADDIU A0, GP, -32692
9D001A24  28420002   SLTI V0, V0, 2
9D001A28  14400146   BNE V0, ZERO, 0x9D001F44
9D001A2C  3C059D00   LUI A1, -25344
222:                             // returns when the thead dies
223:                             // in this case, when <enter> is pushed
224:                             // now parse the string
225:                             sscanf(PT_term_buffer, "%s", cmd);
9D001A30  3C04A000   LUI A0, -24576
9D001A34  248403FC   ADDIU A0, A0, 1020
9D001A38  24A56F48   ADDIU A1, A1, 28488
9D001A3C  3C11A000   LUI S1, -24576
9D001A40  0F401E24   JAL _sscanf_cdfFnopsuxX
9D001A44  2626056C   ADDIU A2, S1, 1388
226:                 
227:                             switch(cmd[0]){
9D001A48  9222056C   LBU V0, 1388(S1)
9D001A4C  2442FF9F   ADDIU V0, V0, -97
9D001A50  304300FF   ANDI V1, V0, 255
9D001A54  2C630017   SLTIU V1, V1, 23
9D001A58  1060FFDD   BEQ V1, ZERO, 0x9D0019D0
9D001A5C  304200FF   ANDI V0, V0, 255
9D001A60  00021080   SLL V0, V0, 2
9D001A64  3C039D00   LUI V1, -25344
9D001A68  24631A7C   ADDIU V1, V1, 6780
9D001A6C  00621021   ADDU V0, V1, V0
9D001A70  8C420000   LW V0, 0(V0)
9D001A74  00400008   JR V0
9D001A78  00000000   NOP
228:                                 case 'w': // set weight parameters: source dest value 
229:                                     if (cmd[1]=='w'){
9D001AD8  3C02A000   LUI V0, -24576
9D001ADC  8043056D   LB V1, 1389(V0)
9D001AE0  24020077   ADDIU V0, ZERO, 119
9D001AE4  1462001F   BNE V1, V0, 0x9D001B64
9D001AE8  3C02A000   LUI V0, -24576
230:                                         sscanf(PT_term_buffer, "%s %d %d %f", cmd, &iv1, &iv2, &fv1); 
9D001AEC  27828070   ADDIU V0, GP, -32656
9D001AF0  AFA20010   SW V0, 16(SP)
9D001AF4  27828074   ADDIU V0, GP, -32652
9D001AF8  AFA20014   SW V0, 20(SP)
9D001AFC  3C04A000   LUI A0, -24576
9D001B00  248403FC   ADDIU A0, A0, 1020
9D001B04  3C059D00   LUI A1, -25344
9D001B08  24A56F4C   ADDIU A1, A1, 28492
9D001B0C  3C06A000   LUI A2, -24576
9D001B10  24C6056C   ADDIU A2, A2, 1388
9D001B14  0F401E24   JAL _sscanf_cdfFnopsuxX
9D001B18  2787806C   ADDIU A3, GP, -32660
231:                                         w_syn[iv1][iv2] = float2fix14(fv1);
9D001B1C  8F82806C   LW V0, -32660(GP)
9D001B20  00028840   SLL S1, V0, 1
9D001B24  000210C0   SLL V0, V0, 3
9D001B28  02228821   ADDU S1, S1, V0
9D001B2C  8F828070   LW V0, -32656(GP)
9D001B30  02228821   ADDU S1, S1, V0
9D001B34  00118840   SLL S1, S1, 1
9D001B38  3C02A000   LUI V0, -24576
9D001B3C  24420208   ADDIU V0, V0, 520
9D001B40  02228821   ADDU S1, S1, V0
9D001B44  8F848074   LW A0, -32652(GP)
9D001B48  3C029D00   LUI V0, -25344
9D001B4C  0F401691   JAL __mulsf3
9D001B50  8C456FC0   LW A1, 28608(V0)
9D001B54  0F401D1A   JAL __fixsfsi
9D001B58  00402021   ADDU A0, V0, ZERO
9D001B5C  A6220000   SH V0, 0(S1)
232:                                     }
233:                                     if (cmd[1]=='r'){
9D001B60  3C02A000   LUI V0, -24576
9D001B64  8043056D   LB V1, 1389(V0)
9D001B68  24020072   ADDIU V0, ZERO, 114
9D001B6C  1462FF99   BNE V1, V0, 0x9D0019D4
9D001B70  3C02A000   LUI V0, -24576
234:                                         sscanf(PT_term_buffer, "%s %d %d", cmd, &iv1, &iv2); 
9D001B74  27828070   ADDIU V0, GP, -32656
9D001B78  AFA20010   SW V0, 16(SP)
9D001B7C  3C04A000   LUI A0, -24576
9D001B80  248403FC   ADDIU A0, A0, 1020
9D001B84  3C059D00   LUI A1, -25344
9D001B88  24A56F58   ADDIU A1, A1, 28504
9D001B8C  3C06A000   LUI A2, -24576
9D001B90  24C6056C   ADDIU A2, A2, 1388
9D001B94  0F401E24   JAL _sscanf_cdfFnopsuxX
9D001B98  2787806C   ADDIU A3, GP, -32660
235:                                         sprintf(PT_send_buffer, "weight %d %d = %f\n\r", iv1, iv2, fix2float14(w_syn[iv1][iv2]));
9D001B9C  8F91806C   LW S1, -32660(GP)
9D001BA0  8F928070   LW S2, -32656(GP)
9D001BA4  00111840   SLL V1, S1, 1
9D001BA8  001110C0   SLL V0, S1, 3
9D001BAC  00621821   ADDU V1, V1, V0
9D001BB0  00721821   ADDU V1, V1, S2
9D001BB4  00031840   SLL V1, V1, 1
9D001BB8  3C02A000   LUI V0, -24576
9D001BBC  24420208   ADDIU V0, V0, 520
9D001BC0  00621021   ADDU V0, V1, V0
9D001BC4  0F401DC8   JAL sitofp
9D001BC8  84440000   LH A0, 0(V0)
9D001BCC  00402021   ADDU A0, V0, ZERO
9D001BD0  3C029D00   LUI V0, -25344
9D001BD4  0F401691   JAL __mulsf3
9D001BD8  8C456FC4   LW A1, 28612(V0)
9D001BDC  AFA20010   SW V0, 16(SP)
9D001BE0  3C04A000   LUI A0, -24576
9D001BE4  248400D8   ADDIU A0, A0, 216
9D001BE8  3C059D00   LUI A1, -25344
9D001BEC  24A56F64   ADDIU A1, A1, 28516
9D001BF0  02203021   ADDU A2, S1, ZERO
9D001BF4  0F401D94   JAL _sprintf_cdfFnopuxX
9D001BF8  02403821   ADDU A3, S2, ZERO
236:                                         PT_SPAWN(pt, &pt_DMA_output, PT_DMA_PutSerialBuffer(&pt_DMA_output) ); 
9D001BFC  AF80805C   SW ZERO, -32676(GP)
9D001C00  3C029D00   LUI V0, -25344
9D001C04  24421C00   ADDIU V0, V0, 7168
9D001C08  AE020000   SW V0, 0(S0)
9D001C0C  0F4005A4   JAL PT_DMA_PutSerialBuffer
9D001C10  2784805C   ADDIU A0, GP, -32676
9D001C14  28420002   SLTI V0, V0, 2
9D001C18  144000CA   BNE V0, ZERO, 0x9D001F44
9D001C1C  8F91806C   LW S1, -32660(GP)
237:                                         sprintf(PT_send_buffer, "-weight %d %d = %f\n\r", iv1, iv2, fix2float14(weight_minus[iv1][iv2]));
9D001C20  8F928070   LW S2, -32656(GP)
9D001C24  00111840   SLL V1, S1, 1
9D001C28  001110C0   SLL V0, S1, 3
9D001C2C  00621821   ADDU V1, V1, V0
9D001C30  00721821   ADDU V1, V1, S2
9D001C34  00031840   SLL V1, V1, 1
9D001C38  3C02A000   LUI V0, -24576
9D001C3C  2442030C   ADDIU V0, V0, 780
9D001C40  00621021   ADDU V0, V1, V0
9D001C44  0F401DC8   JAL sitofp
9D001C48  84440000   LH A0, 0(V0)
9D001C4C  00402021   ADDU A0, V0, ZERO
9D001C50  3C029D00   LUI V0, -25344
9D001C54  0F401691   JAL __mulsf3
9D001C58  8C456FC4   LW A1, 28612(V0)
9D001C5C  AFA20010   SW V0, 16(SP)
9D001C60  3C04A000   LUI A0, -24576
9D001C64  248400D8   ADDIU A0, A0, 216
9D001C68  3C059D00   LUI A1, -25344
9D001C6C  24A56F78   ADDIU A1, A1, 28536
9D001C70  02203021   ADDU A2, S1, ZERO
9D001C74  0F401D94   JAL _sprintf_cdfFnopuxX
9D001C78  02403821   ADDU A3, S2, ZERO
238:                                         PT_SPAWN(pt, &pt_DMA_output, PT_DMA_PutSerialBuffer(&pt_DMA_output) );
9D001C7C  AF80805C   SW ZERO, -32676(GP)
9D001C80  3C029D00   LUI V0, -25344
9D001C84  24421C80   ADDIU V0, V0, 7296
9D001C88  AE020000   SW V0, 0(S0)
9D001C8C  0F4005A4   JAL PT_DMA_PutSerialBuffer
9D001C90  2784805C   ADDIU A0, GP, -32676
9D001C94  28420002   SLTI V0, V0, 2
9D001C98  144000AA   BNE V0, ZERO, 0x9D001F44
9D001C9C  8F91806C   LW S1, -32660(GP)
239:                                         sprintf(PT_send_buffer, "+weight %d %d = %f\n\r", iv1, iv2, fix2float14(weight_plus[iv1][iv2]));
9D001CA0  8F928070   LW S2, -32656(GP)
9D001CA4  00111840   SLL V1, S1, 1
9D001CA8  001110C0   SLL V0, S1, 3
9D001CAC  00621821   ADDU V1, V1, V0
9D001CB0  00721821   ADDU V1, V1, S2
9D001CB4  00031840   SLL V1, V1, 1
9D001CB8  3C02A000   LUI V0, -24576
9D001CBC  24420118   ADDIU V0, V0, 280
9D001CC0  00621021   ADDU V0, V1, V0
9D001CC4  0F401DC8   JAL sitofp
9D001CC8  84440000   LH A0, 0(V0)
9D001CCC  00402021   ADDU A0, V0, ZERO
9D001CD0  3C029D00   LUI V0, -25344
9D001CD4  0F401691   JAL __mulsf3
9D001CD8  8C456FC4   LW A1, 28612(V0)
9D001CDC  AFA20010   SW V0, 16(SP)
9D001CE0  3C04A000   LUI A0, -24576
9D001CE4  248400D8   ADDIU A0, A0, 216
9D001CE8  3C059D00   LUI A1, -25344
9D001CEC  24A56F90   ADDIU A1, A1, 28560
9D001CF0  02203021   ADDU A2, S1, ZERO
9D001CF4  0F401D94   JAL _sprintf_cdfFnopuxX
9D001CF8  02403821   ADDU A3, S2, ZERO
240:                                         PT_SPAWN(pt, &pt_DMA_output, PT_DMA_PutSerialBuffer(&pt_DMA_output) );
9D001CFC  AF80805C   SW ZERO, -32676(GP)
9D001D00  3C029D00   LUI V0, -25344
9D001D04  24421D00   ADDIU V0, V0, 7424
9D001D08  AE020000   SW V0, 0(S0)
9D001D0C  0F4005A4   JAL PT_DMA_PutSerialBuffer
9D001D10  2784805C   ADDIU A0, GP, -32676
9D001D14  28420002   SLTI V0, V0, 2
9D001D18  5040FF2E   BEQL V0, ZERO, 0x9D0019D4
9D001D1C  3C02A000   LUI V0, -24576
9D001D20  0B4007D2   J 0x9D001F48
9D001D24  00001021   ADDU V0, ZERO, ZERO
241:                                     }
242:                                    break;
243:                 
244:                                 case 'p': // set DAC display parameters: Asource Bsource
245:                                    sscanf(PT_term_buffer, "%s %d %d", cmd, &iv1, &iv2); 
9D001D28  27828070   ADDIU V0, GP, -32656
9D001D2C  AFA20010   SW V0, 16(SP)
9D001D30  3C04A000   LUI A0, -24576
9D001D34  248403FC   ADDIU A0, A0, 1020
9D001D38  3C059D00   LUI A1, -25344
9D001D3C  24A56F58   ADDIU A1, A1, 28504
9D001D40  3C06A000   LUI A2, -24576
9D001D44  24C6056C   ADDIU A2, A2, 1388
9D001D48  0F401E24   JAL _sscanf_cdfFnopsuxX
9D001D4C  2787806C   ADDIU A3, GP, -32660
246:                                    DAC_A_source = iv1 ;
9D001D50  8F82806C   LW V0, -32660(GP)
9D001D54  AF828064   SW V0, -32668(GP)
247:                                    DAC_B_source = iv2 ;
9D001D58  8F828070   LW V0, -32656(GP)
248:                                    break;
9D001D5C  0B400674   J 0x9D0019D0
9D001D60  AF828024   SW V0, -32732(GP)
249:                                 
250:                                 case 'a': // set DAC display parameters: neuron a
251:                                    sscanf(PT_term_buffer, "%s %d %d", cmd, &iv1, &iv2); 
9D001D64  27828070   ADDIU V0, GP, -32656
9D001D68  AFA20010   SW V0, 16(SP)
9D001D6C  3C04A000   LUI A0, -24576
9D001D70  248403FC   ADDIU A0, A0, 1020
9D001D74  3C059D00   LUI A1, -25344
9D001D78  24A56F58   ADDIU A1, A1, 28504
9D001D7C  3C06A000   LUI A2, -24576
9D001D80  24C6056C   ADDIU A2, A2, 1388
9D001D84  0F401E24   JAL _sscanf_cdfFnopsuxX
9D001D88  2787806C   ADDIU A3, GP, -32660
252:                                    a[iv1] = iv2 ;
9D001D8C  8F83806C   LW V1, -32660(GP)
9D001D90  00031840   SLL V1, V1, 1
9D001D94  3C02A000   LUI V0, -24576
9D001D98  244203E8   ADDIU V0, V0, 1000
9D001D9C  00621021   ADDU V0, V1, V0
9D001DA0  8F838070   LW V1, -32656(GP)
253:                                    break;
9D001DA4  0B400674   J 0x9D0019D0
9D001DA8  A4430000   SH V1, 0(V0)
254:                                    
255:                                 case 'b': // set DAC display parameters: neuron b
256:                                    sscanf(PT_term_buffer, "%s %d %d", cmd, &iv1, &iv2); 
9D001DAC  27828070   ADDIU V0, GP, -32656
9D001DB0  AFA20010   SW V0, 16(SP)
9D001DB4  3C04A000   LUI A0, -24576
9D001DB8  248403FC   ADDIU A0, A0, 1020
9D001DBC  3C059D00   LUI A1, -25344
9D001DC0  24A56F58   ADDIU A1, A1, 28504
9D001DC4  3C06A000   LUI A2, -24576
9D001DC8  24C6056C   ADDIU A2, A2, 1388
9D001DCC  0F401E24   JAL _sscanf_cdfFnopsuxX
9D001DD0  2787806C   ADDIU A3, GP, -32660
257:                                    a[iv1] = iv2 ;
9D001DD4  8F83806C   LW V1, -32660(GP)
9D001DD8  00031840   SLL V1, V1, 1
9D001DDC  3C02A000   LUI V0, -24576
9D001DE0  244203E8   ADDIU V0, V0, 1000
9D001DE4  00621021   ADDU V0, V1, V0
9D001DE8  8F838070   LW V1, -32656(GP)
258:                                    break;
9D001DEC  0B400674   J 0x9D0019D0
9D001DF0  A4430000   SH V1, 0(V0)
259:                                    
260:                                 case 'c': // set DAC display parameters: neuron c/100
261:                                    sscanf(PT_term_buffer, "%s %d %f", cmd, &iv1, &fv2); 
9D001DF4  27828078   ADDIU V0, GP, -32648
9D001DF8  AFA20010   SW V0, 16(SP)
9D001DFC  3C04A000   LUI A0, -24576
9D001E00  248403FC   ADDIU A0, A0, 1020
9D001E04  3C059D00   LUI A1, -25344
9D001E08  24A56FA8   ADDIU A1, A1, 28584
9D001E0C  3C06A000   LUI A2, -24576
9D001E10  24C6056C   ADDIU A2, A2, 1388
9D001E14  0F401E24   JAL _sscanf_cdfFnopsuxX
9D001E18  2787806C   ADDIU A3, GP, -32660
262:                                    c[iv1] = float2fix14(fv2);
9D001E1C  8F91806C   LW S1, -32660(GP)
9D001E20  00118840   SLL S1, S1, 1
9D001E24  3C02A000   LUI V0, -24576
9D001E28  244202D0   ADDIU V0, V0, 720
9D001E2C  02228821   ADDU S1, S1, V0
9D001E30  8F848078   LW A0, -32648(GP)
9D001E34  3C029D00   LUI V0, -25344
9D001E38  0F401691   JAL __mulsf3
9D001E3C  8C456FC0   LW A1, 28608(V0)
9D001E40  0F401D1A   JAL __fixsfsi
9D001E44  00402021   ADDU A0, V0, ZERO
263:                                    break;
9D001E48  0B400674   J 0x9D0019D0
9D001E4C  A6220000   SH V0, 0(S1)
264:                                    
265:                                 case 'd': // set DAC display parameters: neuron d/100
266:                                    sscanf(PT_term_buffer, "%s %d %f", cmd, &iv1, &fv2); 
9D001E50  27828078   ADDIU V0, GP, -32648
9D001E54  AFA20010   SW V0, 16(SP)
9D001E58  3C04A000   LUI A0, -24576
9D001E5C  248403FC   ADDIU A0, A0, 1020
9D001E60  3C059D00   LUI A1, -25344
9D001E64  24A56FA8   ADDIU A1, A1, 28584
9D001E68  3C06A000   LUI A2, -24576
9D001E6C  24C6056C   ADDIU A2, A2, 1388
9D001E70  0F401E24   JAL _sscanf_cdfFnopsuxX
9D001E74  2787806C   ADDIU A3, GP, -32660
267:                                    d[iv1] = float2fix14(fv2);
9D001E78  8F91806C   LW S1, -32660(GP)
9D001E7C  00118840   SLL S1, S1, 1
9D001E80  3C02A000   LUI V0, -24576
9D001E84  244202F8   ADDIU V0, V0, 760
9D001E88  02228821   ADDU S1, S1, V0
9D001E8C  8F848078   LW A0, -32648(GP)
9D001E90  3C029D00   LUI V0, -25344
9D001E94  0F401691   JAL __mulsf3
9D001E98  8C456FC0   LW A1, 28608(V0)
9D001E9C  0F401D1A   JAL __fixsfsi
9D001EA0  00402021   ADDU A0, V0, ZERO
268:                                    break;
9D001EA4  0B400674   J 0x9D0019D0
9D001EA8  A6220000   SH V0, 0(S1)
269:                                    
270:                                 case 'i': // set DAC display parameters: neuron Is/100
271:                                    sscanf(PT_term_buffer, "%s %d %f", cmd, &iv1, &fv2); 
9D001EAC  27828078   ADDIU V0, GP, -32648
9D001EB0  AFA20010   SW V0, 16(SP)
9D001EB4  3C04A000   LUI A0, -24576
9D001EB8  248403FC   ADDIU A0, A0, 1020
9D001EBC  3C059D00   LUI A1, -25344
9D001EC0  24A56FA8   ADDIU A1, A1, 28584
9D001EC4  3C06A000   LUI A2, -24576
9D001EC8  24C6056C   ADDIU A2, A2, 1388
9D001ECC  0F401E24   JAL _sscanf_cdfFnopsuxX
9D001ED0  2787806C   ADDIU A3, GP, -32660
272:                                    Is[iv1] = float2fix14(fv2);
9D001ED4  8F91806C   LW S1, -32660(GP)
9D001ED8  00118840   SLL S1, S1, 1
9D001EDC  3C02A000   LUI V0, -24576
9D001EE0  244203D4   ADDIU V0, V0, 980
9D001EE4  02228821   ADDU S1, S1, V0
9D001EE8  8F848078   LW A0, -32648(GP)
9D001EEC  3C029D00   LUI V0, -25344
9D001EF0  0F401691   JAL __mulsf3
9D001EF4  8C456FC0   LW A1, 28608(V0)
9D001EF8  0F401D1A   JAL __fixsfsi
9D001EFC  00402021   ADDU A0, V0, ZERO
273:                                    break;
9D001F00  0B400674   J 0x9D0019D0
9D001F04  A6220000   SH V0, 0(S1)
274:                                    
275:                                 case 'r': // frame/second
276:                                    sprintf(PT_send_buffer, "fps = %d\n\r", fps);
9D001F08  3C04A000   LUI A0, -24576
9D001F0C  248400D8   ADDIU A0, A0, 216
9D001F10  3C059D00   LUI A1, -25344
9D001F14  24A56FB4   ADDIU A1, A1, 28596
9D001F18  0F401D94   JAL _sprintf_cdfFnopuxX
9D001F1C  8F8680BC   LW A2, -32580(GP)
277:                                    PT_SPAWN(pt, &pt_DMA_output, PT_DMA_PutSerialBuffer(&pt_DMA_output) );
9D001F20  AF80805C   SW ZERO, -32676(GP)
9D001F24  3C029D00   LUI V0, -25344
9D001F28  24421F24   ADDIU V0, V0, 7972
9D001F2C  AE020000   SW V0, 0(S0)
9D001F30  0F4005A4   JAL PT_DMA_PutSerialBuffer
9D001F34  2784805C   ADDIU A0, GP, -32676
9D001F38  28420002   SLTI V0, V0, 2
9D001F3C  1040FEA5   BEQ V0, ZERO, 0x9D0019D4
9D001F40  3C02A000   LUI V0, -24576
278:                                    break;
279:                             }
280:                              
281:                             // never exit while
282:                       } // END WHILE(1)
283:                   PT_END(pt);
284:                 } // thread 3
9D001F44  00001021   ADDU V0, ZERO, ZERO
9D001F48  8FBF0024   LW RA, 36(SP)
9D001F4C  8FB20020   LW S2, 32(SP)
9D001F50  8FB1001C   LW S1, 28(SP)
9D001F54  8FB00018   LW S0, 24(SP)
9D001F58  03E00008   JR RA
9D001F5C  27BD0028   ADDIU SP, SP, 40
285:                 
286:                 // === Neural Thread ================================================
287:                 
288:                 static PT_THREAD (protothread_Izhikevich(struct pt *pt))
289:                 {
9D001F60  27BDFFD0   ADDIU SP, SP, -48
9D001F64  AFBF002C   SW RA, 44(SP)
9D001F68  AFB60028   SW S6, 40(SP)
9D001F6C  AFB50024   SW S5, 36(SP)
9D001F70  AFB40020   SW S4, 32(SP)
9D001F74  AFB3001C   SW S3, 28(SP)
9D001F78  AFB20018   SW S2, 24(SP)
9D001F7C  AFB10014   SW S1, 20(SP)
9D001F80  AFB00010   SW S0, 16(SP)
290:                     PT_BEGIN(pt);
9D001F84  8C820000   LW V0, 0(A0)
9D001F88  1440010A   BNE V0, ZERO, 0x9D0023B4
9D001F8C  00808021   ADDU S0, A0, ZERO
291:                     static int i,j ;
292:                     // 
293:                     #define max_rand_weight 0.000 //0.005 
294:                     // some small, uniform, random, weights
295:                     for(i=0; i<n_neuron; i++){  
9D001F90  AF808088   SW ZERO, -32632(GP)
9D00206C  8F828088   LW V0, -32632(GP)
9D002070  24420001   ADDIU V0, V0, 1
9D002074  AF828088   SW V0, -32632(GP)
9D002078  2842000A   SLTI V0, V0, 10
9D00207C  5440FFCE   BNEL V0, ZERO, 0x9D001FB8
9D002080  AF80808C   SW ZERO, -32628(GP)
296:                         for(j=0; j<n_neuron; j++){
9D001FB4  AF80808C   SW ZERO, -32628(GP)
9D001FB8  00008821   ADDU S1, ZERO, ZERO
9D002058  2843000A   SLTI V1, V0, 10
9D00205C  10600003   BEQ V1, ZERO, 0x9D00206C
9D002060  AF82808C   SW V0, -32628(GP)
9D002064  0B4007EF   J 0x9D001FBC
9D002068  00408821   ADDU S1, V0, ZERO
297:                              w_syn[j][i] = randfix14(max_rand_weight) ;
9D001F94  3C12A000   LUI S2, -24576
9D001F98  26520208   ADDIU S2, S2, 520
9D001F9C  3C029D00   LUI V0, -25344
9D001FA0  8C556FC8   LW S5, 28616(V0)
9D001FA4  3C029D00   LUI V0, -25344
9D001FA8  8C546FCC   LW S4, 28620(V0)
9D001FAC  3C029D00   LUI V0, -25344
9D001FB0  8C536FC0   LW S3, 28608(V0)
9D001FBC  0F401CB5   JAL rand
9D001FC0  8F968088   LW S6, -32632(GP)
9D001FC4  00111840   SLL V1, S1, 1
9D001FC8  001188C0   SLL S1, S1, 3
9D001FCC  00718821   ADDU S1, V1, S1
9D001FD0  02368821   ADDU S1, S1, S6
9D001FD4  00118840   SLL S1, S1, 1
9D001FD8  02328821   ADDU S1, S1, S2
9D001FDC  0F401DC8   JAL sitofp
9D001FE0  00402021   ADDU A0, V0, ZERO
9D001FE4  00402021   ADDU A0, V0, ZERO
9D001FE8  0F40145D   JAL fpadd
9D001FEC  00402821   ADDU A1, V0, ZERO
9D001FF0  00402021   ADDU A0, V0, ZERO
9D001FF4  0F401691   JAL __mulsf3
9D001FF8  02A02821   ADDU A1, S5, ZERO
9D001FFC  00402021   ADDU A0, V0, ZERO
9D002000  0F40145B   JAL __subsf3
9D002004  02802821   ADDU A1, S4, ZERO
9D002008  00402021   ADDU A0, V0, ZERO
9D00200C  0F401691   JAL __mulsf3
9D002010  00002821   ADDU A1, ZERO, ZERO
9D002014  00402021   ADDU A0, V0, ZERO
9D002018  0F401691   JAL __mulsf3
9D00201C  02602821   ADDU A1, S3, ZERO
9D002020  0F401D1A   JAL __fixsfsi
9D002024  00402021   ADDU A0, V0, ZERO
9D002028  A6220000   SH V0, 0(S1)
298:                              if (i==j) w_syn[j][i] = 0; // no self connection
9D00202C  8F838088   LW V1, -32632(GP)
9D002030  8F82808C   LW V0, -32628(GP)
9D002034  14620008   BNE V1, V0, 0x9D002058
9D002038  24420001   ADDIU V0, V0, 1
9D00203C  00032080   SLL A0, V1, 2
9D002040  00032900   SLL A1, V1, 4
9D002044  00A42023   SUBU A0, A1, A0
9D002048  00831823   SUBU V1, A0, V1
9D00204C  00031840   SLL V1, V1, 1
9D002050  00721821   ADDU V1, V1, S2
9D002054  A4600000   SH ZERO, 0(V1)
299:                         }
300:                     }
301:                     //  two bigger  weights
302:                     //w_syn[2][1] = float2fix14(-0.07); //-0.07
303:                     //w_syn[1][2] = float2fix14(-0.07); //-0.07
304:                     
305:                     // default display voltages
306:                     DAC_A_source = 1 ;
9D002084  24020001   ADDIU V0, ZERO, 1
9D002088  AF828064   SW V0, -32668(GP)
307:                     DAC_B_source = 0 ;
9D00208C  AF808024   SW ZERO, -32732(GP)
9D002090  3C02A000   LUI V0, -24576
9D002094  844403D4   LH A0, 980(V0)
9D002098  3C03A000   LUI V1, -24576
9D00209C  2463043C   ADDIU V1, V1, 1084
308:                                     
309:                     // the initial conditions
310:                     for(i=0; i<n_neuron; i++){
9D0020A0  00001021   ADDU V0, ZERO, ZERO
9D0020A4  3C11A000   LUI S1, -24576
9D0020A8  263102E4   ADDIU S1, S1, 740
9D0020F0  24070014   ADDIU A3, ZERO, 20
9D0020F4  02223021   ADDU A2, S1, V0
9D00213C  1447FFED   BNE V0, A3, 0x9D0020F4
9D002140  24630001   ADDIU V1, V1, 1
9D002144  3C02A000   LUI V0, -24576
9D002148  A44403D4   SH A0, 980(V0)
311:                         v[i] = v_init ;
9D0020AC  2405D667   ADDIU A1, ZERO, -10649
9D0020B0  3C19A000   LUI T9, -24576
9D0020B4  273903E8   ADDIU T9, T9, 1000
9D0020F8  A4C50000   SH A1, 0(A2)
9D0020FC  03223021   ADDU A2, T9, V0
312:                         a[i] = a_type2 ;
9D0020B8  24180006   ADDIU T8, ZERO, 6
9D0020BC  3C0FA000   LUI T7, -24576
9D0020C0  25EF00C4   ADDIU T7, T7, 196
9D002100  A4D80000   SH T8, 0(A2)
9D002104  01E23021   ADDU A2, T7, V0
313:                         b[i] = b_type2 ;
9D0020C4  240E0002   ADDIU T6, ZERO, 2
9D0020C8  3C0DA000   LUI T5, -24576
9D0020CC  25AD02D0   ADDIU T5, T5, 720
9D0020D0  3C0CA000   LUI T4, -24576
9D0020D4  258C02F8   ADDIU T4, T4, 760
9D002108  A4CE0000   SH T6, 0(A2)
9D00210C  01A23021   ADDU A2, T5, V0
314:                         c[i] = c_type2 ;
9D002110  A4C50000   SH A1, 0(A2)
9D002114  01823021   ADDU A2, T4, V0
315:                         d[i] = d_type2 ;
9D0020D8  240B03D7   ADDIU T3, ZERO, 983
9D002118  A4CB0000   SH T3, 0(A2)
316:                         // adding  random gives a little varability between neurons
317:                         //Is[i] = Is_type2 + randfix14(0.001) ;
318:                         if (i==0) Is[i] = float2fix14(0.000) ;
9D0020DC  00605021   ADDU T2, V1, ZERO
9D0020E0  3C09A000   LUI T1, -24576
9D0020E4  25290470   ADDIU T1, T1, 1136
9D0020E8  3C08A000   LUI T0, -24576
9D0020EC  2508045C   ADDIU T0, T0, 1116
9D00211C  01433026   XOR A2, T2, V1
9D002120  0006200A   MOVZ A0, ZERO, A2
319:                         spike[i] = 0;
9D002124  A0600000   SB ZERO, 0(V1)
9D002128  01223021   ADDU A2, T1, V0
320:                         I_syn[i] = 0;
9D00212C  A4C00000   SH ZERO, 0(A2)
9D002130  01023021   ADDU A2, T0, V0
321:                         u_reset[i] = 0;
9D002134  A4C00000   SH ZERO, 0(A2)
9D002138  24420002   ADDIU V0, V0, 2
322:                     }
323:                     
324:                     while(1) {
325:                         //static fix14 temp ;
326:                         compute_counter++;
9D00214C  8F8280A8   LW V0, -32600(GP)
9D002150  24420001   ADDIU V0, V0, 1
9D002154  AF8280A8   SW V0, -32600(GP)
327:                         for(i=0; i<n_neuron; i++){
9D0021C4  240C0014   ADDIU T4, ZERO, 20
9D0022A0  144CFFC9   BNE V0, T4, 0x9D0021C8
9D0022A4  25080004   ADDIU T0, T0, 4
9D0022A8  3C08A000   LUI T0, -24576
9D0022AC  25080470   ADDIU T0, T0, 1136
9D0022B0  3C09A000   LUI T1, -24576
9D0022B4  25290208   ADDIU T1, T1, 520
9D0022B8  250C0014   ADDIU T4, T0, 20
9D0022BC  3C04A000   LUI A0, -24576
9D0022C0  24840446   ADDIU A0, A0, 1094
9D0022C4  01005021   ADDU T2, T0, ZERO
328:                             // update 'voltage' of neuron
329:                             // coded for 1/4 mSec step!
330:                             v[i] = v[i] + (multfix14(v[i],v[i]) + v[i] + shiftfix14(v[i],2) + c14 -  
9D002158  87938018   LH S3, -32744(GP)
9D0021C8  84A30000   LH V1, 0(A1)
9D0021D0  70634802   MUL T1, V1, V1
9D0021D4  00094B83   SRA T1, T1, 14
9D0021D8  7C094E20   SEH T1, T1
9D0021DC  00694821   ADDU T1, V1, T1
9D0021E0  00035083   SRA T2, V1, 2
9D0021E4  012A4821   ADDU T1, T1, T2
9D0021E8  01334821   ADDU T1, T1, S3
9D0021EC  00065083   SRA T2, A2, 2
9D0021F0  012A4823   SUBU T1, T1, T2
9D0021F4  02225021   ADDU T2, S1, V0
9D002214  01231821   ADDU V1, T1, V1
9D002218  7C031E20   SEH V1, V1
9D00221C  A4A30000   SH V1, 0(A1)
9D002220  03024821   ADDU T1, T8, V0
331:                                     shiftfix14(u[i],2) + shiftfix14(Is_total[i]+I_syn[i],2)>>dt_shift_minus2);
9D0021CC  84860000   LH A2, 0(A0)
9D0021F8  85560000   LH S6, 0(T2)
9D0021FC  03225021   ADDU T2, T9, V0
9D002200  854A0000   LH T2, 0(T2)
9D002204  02CA5021   ADDU T2, S6, T2
9D002208  000A5083   SRA T2, T2, 2
9D00220C  012A4821   ADDU T1, T1, T2
9D002210  00094883   SRA T1, T1, 2
332:                             u_reset[i] =  u[i] + d[i];
9D002224  952A0000   LHU T2, 0(T1)
9D002228  94890000   LHU T1, 0(A0)
9D00222C  01494821   ADDU T1, T2, T1
9D002230  7C094E20   SEH T1, T1
9D002234  01E25021   ADDU T2, T7, V0
9D002238  A5490000   SH T1, 0(T2)
9D00223C  01C25021   ADDU T2, T6, V0
333:                             u[i] = u[i] + ((((v[i]>>b[i])-u[i])>>a[i])>>dt_shift);
9D002240  854A0000   LH T2, 0(T2)
9D002244  01435007   SRAV T2, V1, T2
9D002248  01465023   SUBU T2, T2, A2
9D00224C  01A2B021   ADDU S6, T5, V0
9D002250  86D60000   LH S6, 0(S6)
9D002254  02CA5007   SRAV T2, T2, S6
9D002258  000A5103   SRA T2, T2, 4
9D00225C  01463021   ADDU A2, T2, A2
9D002260  A4860000   SH A2, 0(A0)
334:                             // 1/16 mSec step
335:                             //v[i] = v[i] + shiftfix14(multfix14(v[i],v[i]) + v[i] + shiftfix14(v[i],2) + c14 -  
336:                             //        shiftfix14(u[i],2) + shiftfix14(Is[i]+I_syn[i],2), 2);
337:                             // update 'inactivation' of neuron
338:                             //u_reset[i] =  u[i] + d[i];
339:                             //u[i] = u[i] + ((((v[i]>>b[i])-u[i])>>a[i])>>4);
340:                             
341:                 
342:                             // handle 'action potential peak'
343:                             spike[i] = 0 ;
344:                             if(v[i] > peak){
9D00215C  8792801A   LH S2, -32742(GP)
9D002160  3C05A000   LUI A1, -24576
9D002164  24A502E4   ADDIU A1, A1, 740
9D002168  3C04A000   LUI A0, -24576
9D00216C  24840448   ADDIU A0, A0, 1096
9D002170  3C0BA000   LUI T3, -24576
9D002174  256B043C   ADDIU T3, T3, 1084
9D002178  3C08A000   LUI T0, -24576
9D00217C  250801E0   ADDIU T0, T0, 480
9D002180  01603821   ADDU A3, T3, ZERO
9D002184  00001021   ADDU V0, ZERO, ZERO
9D002188  3C11A000   LUI S1, -24576
9D00218C  263100B0   ADDIU S1, S1, 176
9D002190  3C19A000   LUI T9, -24576
9D002194  27390470   ADDIU T9, T9, 1136
9D002198  3C18A000   LUI T8, -24576
9D00219C  271802F8   ADDIU T8, T8, 760
9D0021A0  3C0FA000   LUI T7, -24576
9D0021A4  25EF045C   ADDIU T7, T7, 1116
9D0021A8  3C0EA000   LUI T6, -24576
9D0021AC  25CE00C4   ADDIU T6, T6, 196
9D0021B0  3C0DA000   LUI T5, -24576
9D0021B4  25AD03E8   ADDIU T5, T5, 1000
9D0021B8  3C15A000   LUI S5, -24576
9D0021BC  26B502D0   ADDIU S5, S5, 720
9D002264  0243182A   SLT V1, S2, V1
9D002268  10600009   BEQ V1, ZERO, 0x9D002290
9D00226C  A0E00000   SB ZERO, 0(A3)
9D002270  02A21821   ADDU V1, S5, V0
345:                                 v[i] = c[i] ;
9D002274  94630000   LHU V1, 0(V1)
9D002278  A4A30000   SH V1, 0(A1)
346:                                 u[i] = u_reset[i] ;
9D00227C  A4890000   SH T1, 0(A0)
347:                                 spike[i] = 1;
9D0021C0  24140001   ADDIU S4, ZERO, 1
9D002280  A0F40000   SB S4, 0(A3)
348:                                 cum_spike[i]++;
9D002284  8D030000   LW V1, 0(T0)
9D002288  24630001   ADDIU V1, V1, 1
9D00228C  AD030000   SW V1, 0(T0)
9D002290  24A50002   ADDIU A1, A1, 2
9D002294  24420002   ADDIU V0, V0, 2
9D002298  24840002   ADDIU A0, A0, 2
9D00229C  24E70001   ADDIU A3, A3, 1
349:                             }
350:                         }
351:                         
352:                         // Compute synaptic currents
353:                         // decay time of about 16 time steps
354:                         for(i=0; i<n_neuron; i++){  
9D002310  150CFFEC   BNE T0, T4, 0x9D0022C4
9D002314  25290002   ADDIU T1, T1, 2
9D002318  2402000A   ADDIU V0, ZERO, 10
9D00231C  AF82808C   SW V0, -32628(GP)
9D002320  AF828088   SW V0, -32632(GP)
355:                             // decay the current
356:                             I_syn[i] = I_syn[i] - (I_syn[i]>>dt_shift) ;
9D0022C8  85020000   LH V0, 0(T0)
9D0022CC  00022903   SRA A1, V0, 4
9D0022D0  00452823   SUBU A1, V0, A1
9D0022D4  01201821   ADDU V1, T1, ZERO
9D0022D8  01601021   ADDU V0, T3, ZERO
9D0022DC  7C052E20   SEH A1, A1
357:                             // 1/16
358:                             //I_syn[i] = I_syn[i] - (I_syn[i]>>4) ;
359:                             // add new synaptic inputs
360:                             for(j=0; j<n_neuron; j++){
9D002300  1444FFF7   BNE V0, A0, 0x9D0022E0
9D002304  24630014   ADDIU V1, V1, 20
9D002308  A5450000   SH A1, 0(T2)
9D00230C  25080002   ADDIU T0, T0, 2
361:                                  I_syn[i] =  I_syn[i] + ((spike[j])? w_syn[j][i] : 0) ;
9D0022E0  30A6FFFF   ANDI A2, A1, -1
9D0022E4  80470000   LB A3, 0(V0)
9D0022E8  10E00002   BEQ A3, ZERO, 0x9D0022F4
9D0022EC  00002821   ADDU A1, ZERO, ZERO
9D0022F0  94650000   LHU A1, 0(V1)
9D0022F4  00A62821   ADDU A1, A1, A2
9D0022F8  7C052E20   SEH A1, A1
9D0022FC  24420001   ADDIU V0, V0, 1
362:                                  // STDP -- can just comment out these 4 lines to eliminate learning
363:                                  // presyn spike just before postsyn => causality => raise weight
364:                                  // presyn spike just after  postsyn => non-causality => lower weight     
365:                                 // decay the weight increments and add in new deltas
366:                                 #ifdef learning
367:                                  if(i!=j){
368:                                     w_syn[j][i] = w_syn[j][i] + ((spike[i] && (w_syn[j][i] < max_weight))? weight_plus[j][i]:0) ;
369:                                     w_syn[j][i] = w_syn[j][i] + ((spike[j] && (w_syn[j][i] > -max_weight))? weight_minus[j][i]:0) ;
370:                                     weight_plus[j][i]  = weight_plus[j][i]  - (weight_plus[j][i]>>tau_stdp_plus)  + (spike[j]? d_weight_plus:0);
371:                                     weight_minus[j][i] = weight_minus[j][i] - (weight_minus[j][i]>>tau_stdp_minus) - (spike[i]? d_weight_minus:0);  
372:                                  }
373:                                 // end STDP
374:                                 #endif
375:                             }
376:                         }
377:                           // some DAC output
378:                           mPORTBClearBits(BIT_0); // start transaction
9D002324  24030001   ADDIU V1, ZERO, 1
9D002328  3C02BF88   LUI V0, -16504
9D00232C  AC436134   SW V1, 24884(V0)
379:                           // write to spi2 
380:                           //WriteSPI2( DAC_config_chan_A | fix2dac14(v[DAC_A_source]) );
381:                           WriteSPI2( DAC_config_chan_A | I_syn[0]>>4 );
9D002330  3C02A000   LUI V0, -24576
9D002334  84430470   LH V1, 1136(V0)
9D002338  00031903   SRA V1, V1, 4
9D00233C  34633000   ORI V1, V1, 12288
9D002340  3C02BF80   LUI V0, -16512
9D002344  AC435A20   SW V1, 23072(V0)
382:                           while (SPI2STATbits.SPIBUSY); // wait for end of transaction
9D002348  3C03BF80   LUI V1, -16512
9D00234C  8C625A10   LW V0, 23056(V1)
9D002350  30420800   ANDI V0, V0, 2048
9D002354  1440FFFD   BNE V0, ZERO, 0x9D00234C
9D002358  24020001   ADDIU V0, ZERO, 1
383:                           // end SPI transaction from last interrupt cycle
384:                           mPORTBSetBits(BIT_0);
9D00235C  3C03BF88   LUI V1, -16504
9D002360  AC626138   SW V0, 24888(V1)
385:                           //
386:                           mPORTBClearBits(BIT_0); // start transaction
9D002364  3C03BF88   LUI V1, -16504
9D002368  AC626134   SW V0, 24884(V1)
387:                           // write to spi2 
388:                           WriteSPI2( DAC_config_chan_B | fix2dac14(v[DAC_B_source]) );
9D00236C  8F838024   LW V1, -32732(GP)
9D002370  00031840   SLL V1, V1, 1
9D002374  3C02A000   LUI V0, -24576
9D002378  244202E4   ADDIU V0, V0, 740
9D00237C  00621021   ADDU V0, V1, V0
9D002380  84430000   LH V1, 0(V0)
9D002384  00031903   SRA V1, V1, 4
9D002388  24630800   ADDIU V1, V1, 2048
9D00238C  3463B000   ORI V1, V1, -20480
9D002390  3C02BF80   LUI V0, -16512
9D002394  AC435A20   SW V1, 23072(V0)
389:                           while (SPI2STATbits.SPIBUSY); // wait for end of transaction
9D002398  3C03BF80   LUI V1, -16512
9D00239C  8C625A10   LW V0, 23056(V1)
9D0023A0  30420800   ANDI V0, V0, 2048
9D0023A4  1440FFFD   BNE V0, ZERO, 0x9D00239C
9D0023A8  00000000   NOP
9D0023AC  0B4008F1   J 0x9D0023C4
9D0023B0  24030001   ADDIU V1, ZERO, 1
390:                           // end SPI transaction from last interrupt cycle
391:                           mPORTBSetBits(BIT_0);
9D0023C4  3C02BF88   LUI V0, -16504
9D0023C8  AC436138   SW V1, 24888(V0)
392:                             
393:                           PT_YIELD(pt);
9D0023B4  3C029D00   LUI V0, -25344
9D0023B8  244223B4   ADDIU V0, V0, 9140
9D0023BC  0B400853   J 0x9D00214C
9D0023C0  AC820000   SW V0, 0(A0)
9D0023CC  3C029D00   LUI V0, -25344
9D0023D0  244223B4   ADDIU V0, V0, 9140
9D0023D4  AE020000   SW V0, 0(S0)
394:                           //PT_YIELD_TIME_msec(1) ;
395:                       } // END WHILE(1)
396:                   PT_END(pt);
397:                 } // neuron
9D0023D8  24020001   ADDIU V0, ZERO, 1
9D0023DC  8FBF002C   LW RA, 44(SP)
9D0023E0  8FB60028   LW S6, 40(SP)
9D0023E4  8FB50024   LW S5, 36(SP)
9D0023E8  8FB40020   LW S4, 32(SP)
9D0023EC  8FB3001C   LW S3, 28(SP)
9D0023F0  8FB20018   LW S2, 24(SP)
9D0023F4  8FB10014   LW S1, 20(SP)
9D0023F8  8FB00010   LW S0, 16(SP)
9D0023FC  03E00008   JR RA
9D002400  27BD0030   ADDIU SP, SP, 48
398:                 
399:                 // === the environment =============================================
400:                 // relate a measure of output to form new inputs
401:                 static PT_THREAD (protothread_environment(struct pt *pt))
402:                 {
403:                     PT_BEGIN(pt);
9D002404  8C820000   LW V0, 0(A0)
9D002408  54400008   BNEL V0, ZERO, 0x9D00242C
9D00240C  3C029D00   LUI V0, -25344
404:                       static int i;
405:                       
406:                       while(1) {
407:                             // yield time 
408:                             PT_YIELD_TIME_msec(100) ;
9D002410  8F8280B0   LW V0, -32592(GP)
9D002414  24420064   ADDIU V0, V0, 100
9D002418  AF828090   SW V0, -32624(GP)
9D00241C  3C029D00   LUI V0, -25344
9D002420  2442242C   ADDIU V0, V0, 9260
9D002424  0B400921   J 0x9D002484
9D002428  AC820000   SW V0, 0(A0)
9D00242C  2442242C   ADDIU V0, V0, 9260
9D002430  AC820000   SW V0, 0(A0)
9D002434  8F8380B0   LW V1, -32592(GP)
9D002438  8F828090   LW V0, -32624(GP)
9D00243C  0062102B   SLTU V0, V1, V0
9D002440  14400010   BNE V0, ZERO, 0x9D002484
9D002444  00000000   NOP
409:                             // compute averate rate of  neurons
410:                             for(i=0; i<n_neuron; i++) {
9D002470  1445FFFA   BNE V0, A1, 0x9D00245C
9D002474  7C031E20   SEH V1, V1
9D002478  3C02A000   LUI V0, -24576
9D00247C  0B400904   J 0x9D002410
9D002480  A44300B0   SH V1, 176(V0)
411:                                 // scale and feed back a small inhibition
412:                                // note that avg_rate will be a small-valued integer
413:                                // which translates to a small, fractional, positive fix14
414:                                 //I_syn[0] += cum_spike[i]*1000 ;
415:                                 Is_total[0] = Is[0] + cum_spike[i]<<5 ;
9D002448  3C02A000   LUI V0, -24576
9D00244C  844603D4   LH A2, 980(V0)
9D002450  3C02A000   LUI V0, -24576
9D002454  244201E0   ADDIU V0, V0, 480
9D002458  24450028   ADDIU A1, V0, 40
9D00245C  8C430000   LW V1, 0(V0)
9D002460  00C31821   ADDU V1, A2, V1
9D002464  00031940   SLL V1, V1, 5
416:                                 cum_spike[i] = 0 ;
9D002468  AC400000   SW ZERO, 0(V0)
9D00246C  24420004   ADDIU V0, V0, 4
417:                             }
418:                             //I_syn[1] += avg_rate[n_neuron-1]*10000 ;
419:                             //I_syn[1] -= avg_rate[n_neuron-2]*10000 ;
420:                                     
421:                             // NEVER exit while
422:                       } // END WHILE(1)
423:                   PT_END(pt);
424:                 } // end thread 
9D002484  03E00008   JR RA
9D002488  24020001   ADDIU V0, ZERO, 1
425:                 
426:                 
427:                 // === Tick ========================================================
428:                 // update a 1 second tick counter
429:                 static PT_THREAD (protothread_tick(struct pt *pt))
430:                 {
431:                     PT_BEGIN(pt);
9D00248C  8C820000   LW V0, 0(A0)
9D002490  54400008   BNEL V0, ZERO, 0x9D0024B4
9D002494  3C029D00   LUI V0, -25344
432:                 
433:                       while(1) {
434:                             // yield time 1 second
435:                             PT_YIELD_TIME_msec(1000) ;
9D002498  8F8280B0   LW V0, -32592(GP)
9D00249C  244203E8   ADDIU V0, V0, 1000
9D0024A0  AF828084   SW V0, -32636(GP)
9D0024A4  3C029D00   LUI V0, -25344
9D0024A8  244224B4   ADDIU V0, V0, 9396
9D0024AC  0B40093B   J 0x9D0024EC
9D0024B0  AC820000   SW V0, 0(A0)
9D0024B4  244224B4   ADDIU V0, V0, 9396
9D0024B8  AC820000   SW V0, 0(A0)
9D0024BC  8F8380B0   LW V1, -32592(GP)
9D0024C0  8F828084   LW V0, -32636(GP)
9D0024C4  0062102B   SLTU V0, V1, V0
9D0024C8  14400008   BNE V0, ZERO, 0x9D0024EC
9D0024CC  00000000   NOP
436:                             // compute rate of neuron simulation
437:                             fps = compute_counter;
9D0024D0  8F8280A8   LW V0, -32600(GP)
9D0024D4  AF8280BC   SW V0, -32580(GP)
438:                             compute_counter = 0 ;
9D0024D8  AF8080A8   SW ZERO, -32600(GP)
439:                             sys_time_seconds++ ;
9D0024DC  8F8280A0   LW V0, -32608(GP)
9D0024E0  24420001   ADDIU V0, V0, 1
440:                             // NEVER exit while
441:                       } // END WHILE(1)
9D0024E4  0B400926   J 0x9D002498
9D0024E8  AF8280A0   SW V0, -32608(GP)
442:                   PT_END(pt);
443:                 } // end thread 
9D0024EC  03E00008   JR RA
9D0024F0  24020001   ADDIU V0, ZERO, 1
444:                 
445:                 // === Main  ======================================================
446:                 // set up UART, timer2, threads
447:                 // then schedule them as fast as possible
448:                 
449:                 int main(void)
450:                 {
9D0024F4  27BDFFE8   ADDIU SP, SP, -24
9D0024F8  AFBF0014   SW RA, 20(SP)
451:                   // === config the uart, DMA, vref, timer5 ISR =============
452:                   PT_setup();
9D0024FC  0F40060A   JAL PT_setup
9D002500  AFB00010   SW S0, 16(SP)
453:                 
454:                    // === setup system wide interrupts  ====================
455:                   INTEnableSystemMultiVectoredInt();
9D002504  0F401F32   JAL INTEnableSystemMultiVectoredInt
9D002508  00000000   NOP
456:                     
457:                   /// timer interrupt //////////////////////////
458:                     // Set up timer2 on,  interrupts, internal clock, prescalar 1, toggle rate
459:                     // 300 is 100 ksamples/sec at 30 MHz clock
460:                     // 200 is 150 ksamples/sec
461:                     // 150 is 200
462:                     //OpenTimer2(T2_ON | T2_SOURCE_INT | T2_PS_1_1, 150);
463:                     // set up the timer interrupt with a priority of 2
464:                     //ConfigIntTimer2(T2_INT_ON | T2_INT_PRIOR_2);
465:                     //mT2ClearIntFlag(); // and clear the interrupt flag
466:                 
467:                     /// SPI setup //////////////////////////////////////////
468:                     // SCK2 is pin 26 
469:                     // SDO2 (MOSI) is in PPS output group 2, could be connected to RB5 which is pin 14
470:                     PPSOutput(2, RPB5, SDO2);
9D00250C  3C02BF81   LUI V0, -16511
9D002510  9043FB40   LBU V1, -1216(V0)
9D002514  24100004   ADDIU S0, ZERO, 4
9D002518  7E031804   INS V1, S0, 0, 4
9D00251C  A043FB40   SB V1, -1216(V0)
471:                     // control CS for DAC
472:                     mPORTBSetPinsDigitalOut(BIT_0);
9D002520  24020001   ADDIU V0, ZERO, 1
9D002524  3C03BF88   LUI V1, -16504
9D002528  AC626114   SW V0, 24852(V1)
9D00252C  3C03BF88   LUI V1, -16504
9D002530  AC626104   SW V0, 24836(V1)
473:                     mPORTBSetBits(BIT_0);
9D002534  3C03BF88   LUI V1, -16504
9D002538  AC626138   SW V0, 24888(V1)
474:                     // divide Fpb by 2, configure the I/O ports. Not using SS in this example
475:                     // 16 bit transfer CKP=1 CKE=1
476:                     // possibles SPI_OPEN_CKP_HIGH;   SPI_OPEN_SMP_END;  SPI_OPEN_CKE_REV
477:                     // For any given peripherial, you will need to match these
478:                     SpiChnOpen(spiChn, SPI_OPEN_ON | SPI_OPEN_MODE16 | SPI_OPEN_MSTEN | SPI_OPEN_CKE_REV , spiClkDiv);
9D00253C  8F848010   LW A0, -32752(GP)
9D002540  8F868014   LW A2, -32748(GP)
9D002544  0F401C91   JAL SpiChnOpen
9D002548  34058520   ORI A1, ZERO, -31456
479:                     
480:                     // the ADC ///////////////////////////////////////
481:                         // configure and enable the ADC
482:                 	CloseADC10();	// ensure the ADC is off before setting the configuration
9D00254C  3C031000   LUI V1, 4096
9D002550  3C02BF88   LUI V0, -16504
9D002554  AC431064   SW V1, 4196(V0)
9D002558  3C02BF88   LUI V0, -16504
9D00255C  AC401068   SW ZERO, 4200(V0)
9D002560  34028000   ORI V0, ZERO, -32768
9D002564  3C03BF81   LUI V1, -16511
9D002568  AC629004   SW V0, -28668(V1)
483:                 
484:                 	// define  setup parameters for OpenADC10
485:                 	// Turn module on | ouput in integer | trigger mode auto | enable autosample
486:                         // ADC_CLK_AUTO -- Internal counter ends sampling and starts conversion (Auto convert)
487:                         // ADC_AUTO_SAMPLING_ON -- Sampling begins immediately after last conversion completes; SAMP bit is automatically set
488:                         // ADC_AUTO_SAMPLING_OFF -- Sampling begins with AcquireADC10();
489:                         #define PARAM1  ADC_FORMAT_INTG16 | ADC_CLK_AUTO | ADC_AUTO_SAMPLING_ON 
490:                 
491:                 	// define setup parameters for OpenADC10
492:                 	// ADC ref external  | disable offset test | disable scan mode | do 1 sample | use single buf | alternate mode off
493:                 	#define PARAM2  ADC_VREF_AVDD_AVSS | ADC_OFFSET_CAL_DISABLE | ADC_SCAN_OFF | ADC_SAMPLES_PER_INT_1 | ADC_ALT_BUF_OFF | ADC_ALT_INPUT_OFF
494:                         //
495:                 	// Define setup parameters for OpenADC10
496:                         // use peripherial bus clock | set sample time | set ADC clock divider
497:                         // ADC_CONV_CLK_Tcy2 means divide CLK_PB by 2 (max speed)
498:                         // ADC_SAMPLE_TIME_5 seems to work with a source resistance < 1kohm
499:                         // At PB clock 30 MHz, divide by two for ADC_CONV_CLK gives 66 nSec
500:                         #define PARAM3 ADC_CONV_CLK_PB | ADC_SAMPLE_TIME_5 | ADC_CONV_CLK_Tcy2 //ADC_SAMPLE_TIME_15| ADC_CONV_CLK_Tcy2
501:                 
502:                 	// define setup parameters for OpenADC10
503:                 	// set AN4 and  as analog inputs
504:                 	#define PARAM4	ENABLE_AN4_ANA
505:                 
506:                 	// define setup parameters for OpenADC10
507:                 	// do not assign channels to scan
508:                 	#define PARAM5	SKIP_SCAN_ALL
509:                 
510:                 	// use ground as neg ref for A | use AN0 for input A
511:                 	// configure to sample AN4 
512:                 	SetChanADC10( ADC_CH0_NEG_SAMPLEA_NVREF | ADC_CH0_POS_SAMPLEA_AN4 ); // configure to sample AN0
9D00256C  3C040004   LUI A0, 4
9D002570  3C03BF81   LUI V1, -16511
9D002574  AC649040   SW A0, -28608(V1)
513:                 	OpenADC10( PARAM1, PARAM2, PARAM3, PARAM4, PARAM5 ); // configure ADC using the parameters defined above
9D002578  3C03BF88   LUI V1, -16504
9D00257C  AC706118   SW S0, 24856(V1)
9D002580  3C03BF88   LUI V1, -16504
9D002584  AC706108   SW S0, 24840(V1)
9D002588  3C04FFFF   LUI A0, -1
9D00258C  3C03BF81   LUI V1, -16511
9D002590  AC649050   SW A0, -28592(V1)
9D002594  24040500   ADDIU A0, ZERO, 1280
9D002598  3C03BF81   LUI V1, -16511
9D00259C  AC649020   SW A0, -28640(V1)
9D0025A0  3C03BF81   LUI V1, -16511
9D0025A4  AC609010   SW ZERO, -28656(V1)
9D0025A8  240400E4   ADDIU A0, ZERO, 228
9D0025AC  3C03BF81   LUI V1, -16511
9D0025B0  AC649000   SW A0, -28672(V1)
514:                 
515:                 	EnableADC10(); // Enable the ADC
9D0025B4  3C03BF81   LUI V1, -16511
9D0025B8  AC629008   SW V0, -28664(V1)
516:                     
517:                   // === now the threads ====================
518:                 
519:                   // init the threads
520:                   PT_INIT(&pt_cmd);
9D0025BC  AF80802C   SW ZERO, -32724(GP)
521:                   PT_INIT(&pt_tick);
9D0025C0  AF808034   SW ZERO, -32716(GP)
522:                   PT_INIT(&pt_Izhikevich);
9D0025C4  AF80803C   SW ZERO, -32708(GP)
523:                   PT_INIT(&pt_environment);
9D0025C8  AF808044   SW ZERO, -32700(GP)
524:                 
525:                         
526:                   // schedule the threads
527:                   while(1) {
528:                     // round robin Izhikevich
529:                     PT_SCHEDULE(protothread_cmd(&pt_cmd));
9D0025CC  0F40066A   JAL protothread_cmd
9D0025D0  2784802C   ADDIU A0, GP, -32724
530:                     PT_SCHEDULE(protothread_tick(&pt_tick));
9D0025D4  0F400923   JAL protothread_tick
9D0025D8  27848034   ADDIU A0, GP, -32716
531:                     PT_SCHEDULE(protothread_Izhikevich(&pt_Izhikevich));
9D0025DC  0F4007D8   JAL protothread_Izhikevich
9D0025E0  2784803C   ADDIU A0, GP, -32708
532:                     PT_SCHEDULE(protothread_environment(&pt_environment));
9D0025E4  0F400901   JAL protothread_environment
9D0025E8  27848044   ADDIU A0, GP, -32700
9D0025EC  0B400973   J 0x9D0025CC
9D0025F0  00000000   NOP
533:                   }
534:                 } // main
535:                 
536:                 /*
537:                  %cell parameters from Izhikevich web page
538:                  * in the CODE: 
539:                  * --a from this table converted to a approx right shift number so 0.02 becomes 6
540:                  * --b from this table converted to a approx right shift number so 0.25 becomes 2 
541:                  * --c from this table is multiplyed by 0.01 
542:                  * --d from this table is multiplyed by 0.01
543:                  * --Is from this table is multiplyed by 0.01
544:                  * 
545:                  * % a        b        c      d        Is
546:                     0.02      0.2     -65      6       14 ;...    % tonic spiking
547:                     0.02      0.25    -65      6       0.5 ;...   % phasic spiking
548:                     0.02      0.2     -50      2       15 ;...    % tonic bursting -- type3
549:                     0.02      0.25    -55     0.05     0.6 ;...   % phasic bursting
550:                     0.02      0.2     -55     4        10 ;...    % mixed mode
551:                     0.01      0.2     -65     8        30 ;...    % spike frequency adaptation
552:                     0.02      -0.1    -55     6        0  ;...    % Class 1
553:                     0.2       0.26    -65     0        0  ;...    % Class 2
554:                     0.02      0.2     -65     6        7  ;...    % spike latency
555:                     0.05      0.26    -60     0        0  ;...    % subthreshold oscillations
556:                     0.1       0.26    -60     -1       0  ;...    % resonator
557:                     0.02      -0.1    -55     6        0  ;...    % integrator
558:                     0.03      0.25    -60     4        0;...      % rebound spike
559:                     0.03      0.25    -52     0        0;...      % rebound burst
560:                     0.03      0.25    -60     4        0  ;...    % threshold variability
561:                     1         1.5     -60     0      -65  ;...    % bistability
562:                     1       0.2     -60     -21      0  ;...    % DAP
563:                     0.02      1       -55     4        0  ;...    % accomodation
564:                     -0.02      -1      -60     8        80 ;...    % inhibition-induced spiking
565:                     -0.026     -1      -45     0        80];       % inhibition-induced bursting
566:                 
567:                  */
568:                 // From http://people.ece.cornell.edu/land/courses/ece5760/DDA/NeuronIndex.htm
569:                 // Note that v and u are scaled down by a factor of 100 so that the dynamic range is -1 to +1, 
570:                 // as required by the arithmetic system and the D/A converter. 
571:                 // Compared to the equations from Iz paper, the scaled equations have all constant terms divided by 100. 
572:                 // The a and b constants are not scaled (because they are multiplied by the scaled variables), 
573:                 // but c and d are divided by 100. The constant (.04) on the v2 term above is scaled up by 100 
574:                 // because squaring (the scaled) v drops the value by 10,000. The final scaled equations are:
575:                 // v1(n+1) = v1(n) + dt*(4*(v1(n)^2) + 5*v1(n) +1.40 - u1(n) + I)
576:                 // u1(n+1) = u1 + dt*a*(b*v1(n) - u1(n)) 
577:                 // What is actually coded is:
578:                 // for a dt = 1/16 or 2>>4 (millisecond)
579:                 // from the Verilog:
580:                 	// v1(n+1) = v1(n) + dt*(4*(v1(n)^2) + 5*v1(n) +1.40 - u1(n) + I)
581:                 	// but note that what is actually coded is
582:                 	// v1(n+1) = v1(n) + (v1(n)^2) + 5/4*v1(n) +1.40/4 - u1(n)/4 + I/4)/4
583:                 	//signed_mult v1sq(v1xv1, v1, v1);
584:                 	//assign v1new = v1 + ((v1xv1 + v1+(v1>>>2) + (c14>>>2) - (u1>>>2) + (I>>>2))>>>2);
585:                 	
586:                 	// u1(n+1) = u1 + dt*a*(b*v1(n) - u1(n))
587:                 	//assign v1xb = v1>>>b;         //mult (v1xb, v1, b);
588:                 	//assign du1 = (v1xb-u1)>>>a ;  //mult (du1, (v1xb-u1), a);
589:                 	//assign u1new = u1 + (du1>>>4) ; 
590:                 	//assign u1reset = u1 + d ;
---  c:/program files (x86)/microchip/xc32/v1.40/pic32mx/include/peripheral/uart.h  ---------------------
1:                   /*******************************************************************************
2:                     UART Library Interface Definition
3:                   
4:                     Summary:
5:                       This file contains the interface definition for the UART peripheral library.
6:                   
7:                     Description:
8:                       This library provides a low-level abstraction of the UART (Universal
9:                       Asynchronous Receiver/Transmtter) module on Microchip PIC32MX family
10:                      microcontrollers with a convenient C language interface.  It can be used to
11:                      simplify low-level access to the module without the necessity of interacting
12:                      directly with the module's registers, thus hiding differences from one
13:                      microcontroller variant to another.
14:                  *******************************************************************************/
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  FileName:       uart.h
18:                  Dependencies:   See includes
19:                  Processor:      PIC32MX
20:                  
21:                  Compiler:       Microchip MPLAB XC32 v1.00 or higher
22:                  Company:        Microchip Technology Inc.
23:                  
24:                  Copyright  2008-2009 released Microchip Technology Inc.  All rights
25:                  reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************
46:                  
47:                  Author      Date          Description
48:                  -------------------------------------------------------------------------------
49:                  RP          12-Nov-2012   Cleaned up various code examples and comments.
50:                  *******************************************************************************/
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _UART_H_
54:                  #define _UART_H_
55:                  
56:                  #include <xc.h>
57:                  #include <GenericTypeDefs.h>
58:                  #ifndef _PLIB_DISABLE_LEGACY
59:                      #include <peripheral/legacy/uart_legacy.h>  // Legacy definitions, do not use
60:                  #endif
61:                  
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  // *****************************************************************************
79:                  // *****************************************************************************
80:                  // Section: Constants & Data Types
81:                  // *****************************************************************************
82:                  // *****************************************************************************
83:                  
84:                  //DOM-IGNORE-BEGIN
85:                  /****
86:                   NOTE: It might be wise to place the generic clr/set/inv reg structure in
87:                         the device file.  Also the UART register set could also be placed there
88:                  *****/
89:                  typedef struct
90:                  {
91:                      volatile UINT   reg;
92:                      volatile UINT   clr;
93:                      volatile UINT   set;
94:                      volatile UINT   inv;
95:                  }REG_SET;
96:                  
97:                  typedef struct
98:                  {
99:                      volatile REG_SET    mode;
100:                     volatile REG_SET    sta;
101:                     volatile REG_SET    tx;
102:                     volatile REG_SET    rx;
103:                     volatile REG_SET    brg;
104:                 }UART_REGS;
105:                 
106:                 extern UART_REGS * const uartReg[];
107:                 //DOM-IGNORE-END
108:                 
109:                 // *****************************************************************************
110:                 /* UART Module
111:                 
112:                   Summary:
113:                     UART modules supported.
114:                 
115:                   Description:
116:                     This enumeration identifies the available UART modules.
117:                 */
118:                 
119:                 typedef enum
120:                 {
121:                 #if defined _UART1
122:                     // UART1 Module ID.
123:                     UART1 = 0,
124:                 #endif
125:                 #if defined _UART2
126:                     // UART2 Module ID.
127:                     UART2,
128:                 #endif
129:                 #ifdef _UART3
130:                     // UART3 Module ID.
131:                     UART3,
132:                 #endif
133:                 #ifdef _UART4
134:                     // UART4 Module ID (not available if UART1 CTS/RTS used).
135:                     UART4,
136:                 #endif
137:                 #ifdef _UART5
138:                     // UART5 Module ID (not available if UART2 CTS/RTS used).
139:                     UART5,
140:                 #endif
141:                 #ifdef _UART6
142:                     // UART6 Module ID (not available if UART3 CTS/RTS used).
143:                     UART6,
144:                 #endif
145:                     // Number of available UART modules.
146:                     UART_NUMBER_OF_MODULES
147:                 
148:                 } UART_MODULE;
149:                 
150:                 
151:                 // *****************************************************************************
152:                 /* UART Enable Modes
153:                 
154:                   Summary:
155:                     Operating modes of UART.
156:                 
157:                   Description:
158:                     This enumeration defines the supported modes in which the UART may be
159:                     enabled or disbled.
160:                 
161:                   Remarks:
162:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
163:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
164:                     has been pre-loaded with data.
165:                 
166:                     The caller should not rely on the specific numbers assigned to any of these
167:                     values as they may change from one processor to the next.
168:                 */
169:                 
170:                 typedef enum
171:                 {
172:                     // Disables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
173:                     UART_DISABLE        /*DOM-IGNORE-BEGIN*/= 0x00/*DOM-IGNORE-END*/,
174:                 
175:                     // Enables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
176:                     UART_ENABLE         /*DOM-IGNORE-BEGIN*/= 0x80/*DOM-IGNORE-END*/,
177:                 
178:                 
179:                     // UART Module, receiver and transmitter functionality is not.
180:                     // enabled or disabled
181:                     UART_PERIPHERAL     /*DOM-IGNORE-BEGIN*/= 0x01/*DOM-IGNORE-END*/,
182:                 
183:                     // UART Module receiver.
184:                     UART_RX             /*DOM-IGNORE-BEGIN*/= 0x02/*DOM-IGNORE-END*/,
185:                 
186:                     // UART Module transmitter.
187:                     UART_TX             /*DOM-IGNORE-BEGIN*/= 0x04/*DOM-IGNORE-END*/
188:                 
189:                 
190:                 } UART_ENABLE_MODE;
191:                 
192:                 // *****************************************************************************
193:                 /* UART Enable Helper Macro
194:                 
195:                   Summary:
196:                     Macro for enabling module operating modes.
197:                 
198:                   Description:
199:                     This macro creates the proper flags for enabling operating modes of the UART module.
200:                 
201:                   Example:
202:                     <code>
203:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX));
204:                     </code>
205:                 
206:                   Remarks:
207:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
208:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
209:                     has been pre-loaded with data.
210:                 */
211:                 #define UART_ENABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_ENABLE | (a))/*DOM-IGNORE-END*/
212:                 
213:                 // *****************************************************************************
214:                 /* UART Disable Helper Macro
215:                 
216:                   Summary:
217:                     Macro for disabling module operating modes.
218:                 
219:                   Description:
220:                     This macro creates the proper flags for disabling operating modes of the UART module.
221:                 
222:                   Example:
223:                     <code>
224:                     UARTEnable(UART1, UART_DISABLE_FLAGS(UART_TX));
225:                     </code>
226:                 
227:                 */
228:                 #define UART_DISABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_DISABLE | (a))/*DOM-IGNORE-END*/
229:                 
230:                 // *****************************************************************************
231:                 /* UART Configuration Settings
232:                 
233:                   Summary:
234:                     Supported configuration flags for the UART module.
235:                 
236:                   Description:
237:                     This enumeration defines the various configuration options for the UART
238:                     module.  These values can be OR'd together to create a configuration mask
239:                     passed to the UARTConfigure routine.
240:                 
241:                   Remarks:
242:                     Several of the configuration options are mutually exclusive:
243:                     * Only one of the "ENABLE_PINS" modes can be used at a time
244:                     * Only one of the "RTS_WHEN" modes can be used at a time
245:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
246:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
247:                 
248:                     The caller should not rely on the specific numbers assigned to any of these
249:                     values as they may change from one processor ot the next.
250:                 */
251:                 
252:                 typedef enum
253:                 {
254:                     // Enables high-speed range of the UART (see UARTSetBitRate).
255:                     UART_ENABLE_HIGH_SPEED              /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
256:                 
257:                     // Inverts polarity of data interpretation the received (RX) pin.
258:                     UART_INVERT_RECEIVE_POLARITY        /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
259:                 
260:                     // Enables UART TX-to-RX Loop-back mode.
261:                     UART_ENABLE_LOOPBACK                /*DOM-IGNORE-BEGIN*/= 0x00000040/*DOM-IGNORE-END*/,
262:                 
263:                     // Enables Wake-up of the part when a start bit is received.
264:                     UART_ENABLE_WAKE_ON_START           /*DOM-IGNORE-BEGIN*/= 0x00000080/*DOM-IGNORE-END*/,
265:                 
266:                     // Enable Bit-clock for external IrDA transceiver support (Note:  CTS and RTS
267:                     // cannot be used in bit-clock/IrDA mode).
268:                     UART_ENABLE_PINS_BIT_CLOCK          /*DOM-IGNORE-BEGIN*/= 0x00000300/*DOM-IGNORE-END*/,
269:                 
270:                     // Enable Request-To-Send and Clear-To-Send signals (Note: The bit-clock
271:                     // cannot be used in CTS/RTS mode).
272:                     UART_ENABLE_PINS_CTS_RTS            /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
273:                 
274:                     // Enable Request-To-send signal only (Note: The bit-clock and CTS cannot
275:                     // be used in RTS-Only mode).
276:                     UART_ENABLE_PINS_RTS                /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
277:                 
278:                     // Disables use of Clear-To-Send and Request-To-Send signals (Note: This is
279:                     // the default mode and this parameter can be left out if it is desired).
280:                     UART_ENABLE_PINS_TX_RX_ONLY         /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
281:                 
282:                     // If RTS is enabled, it is asserted (driven low) when the receive buffer
283:                     // is not full (i.e., the UART is ready to receive data).  This is also known
284:                     // as "RTS Flow-Control Mode".
285:                     UART_RTS_WHEN_RX_NOT_FULL           /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
286:                 
287:                     // If RTS is enabled, it is asserted (driven low) when the transmit buffer
288:                     // is not empty (i.e., when the UART has data ready to send).  This is also
289:                     // known as "RTS Simplex Mode".
290:                     UART_RTS_WHEN_TX_NOT_EMPTY          /*DOM-IGNORE-BEGIN*/= 0x00000800/*DOM-IGNORE-END*/,
291:                 
292:                     // Enable the IrDA encoder/decoder.
293:                     UART_ENABLE_IRDA                    /*DOM-IGNORE-BEGIN*/= 0x00001000/*DOM-IGNORE-END*/,
294:                 
295:                     // Enables stopping of the UART operation to save power when the core has
296:                     // been put in idle mode.
297:                     UART_ENABLE_STOP_ON_IDLE            /*DOM-IGNORE-BEGIN*/= 0x00002000/*DOM-IGNORE-END*/,
298:                 
299:                     // Inverts the polarity of data sent on the transmit (TX) pin.
300:                     UART_INVERT_TRANSMIT_POLARITY       /*DOM-IGNORE-BEGIN*/= 0x20000000/*DOM-IGNORE-END*/,
301:                 
302:                     // Enables support for IEEE-485 protocol (equivalent the following OR'd
303:                     // together: UART_RTS_WHEN_TX_NOT_EMPTY | UART_ENABLE_PINS_RTS )
304:                     // Note:  The address must still be set using UARTEnableAddressDetect
305:                     // to support IEEE-485 protocol.
306:                     UART_SUPPORT_IEEE_485               /*DOM-IGNORE-BEGIN*/= 0x00000900/*DOM-IGNORE-END*/
307:                 
308:                 } UART_CONFIGURATION;
309:                 
310:                 
311:                 // *****************************************************************************
312:                 /* UART FIFO Modes
313:                 
314:                   Summary:
315:                     Supported FIFO modes for the UART module.
316:                 
317:                   Description:
318:                     This enumeration defines supported FIFO modes that determine when the Tx
319:                     and Rx interrupts will occur.
320:                 
321:                   Remarks:
322:                     These modes consist of two sets of mutially exclusive modes:
323:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
324:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
325:                 
326:                     The caller should not rely on the specific numbers assigned to any of these
327:                     values as they may change from one processor ot the next.
328:                 
329:                 */
330:                 
331:                 typedef enum
332:                 {
333:                     // If enabled, the TX interrupt will occur when the TX buffer is empty.
334:                     UART_INTERRUPT_ON_TX_BUFFER_EMPTY   /*DOM-IGNORE-BEGIN*/= 0x8000/*DOM-IGNORE-END*/,
335:                 
336:                     // If enabled, the TX interrupt will occur when all data has been transmitted.
337:                     UART_INTERRUPT_ON_TX_DONE           /*DOM-IGNORE-BEGIN*/= 0x4000/*DOM-IGNORE-END*/,
338:                 
339:                     // If enabled, the TX interrupt will occur whenever the TX buffer is not
340:                     // full (i.e. there is space available for more data)  This is the default.
341:                     UART_INTERRUPT_ON_TX_NOT_FULL       /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
342:                 
343:                     // If enabled, the RX interrupt will occur whenever the RX buffer is
344:                     // completely full.  (Not supported on PIC32MX5xx, PIC32MX6xx, or PIC32MX7xx.).
345:                     UART_INTERRUPT_ON_RX_FULL           /*DOM-IGNORE-BEGIN*/= 0x00C0/*DOM-IGNORE-END*/,
346:                 
347:                     // If enabled, the RX interrupt will occur whenever the RX buffer is 3/4
348:                     // (three-quarter) full.
349:                     UART_INTERRUPT_ON_RX_3_QUARTER_FULL /*DOM-IGNORE-BEGIN*/= 0x0080/*DOM-IGNORE-END*/,
350:                 
351:                     // If enabled, the RX interrupt will occur wheneer the RX buffer is half
352:                     // full.  (Not supported on PIC32X3xx or PIC32MX4xx.).
353:                     UART_INTERRUPT_ON_RX_HALF_FULL      /*DOM-IGNORE-BEGIN*/= 0x0040/*DOM-IGNORE-END*/,
354:                 
355:                     // If enabled, the RX interrupt will occur whenever the RX buffer has any
356:                     // data.
357:                     UART_INTERRUPT_ON_RX_NOT_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
358:                 
359:                 } UART_FIFO_MODE;
360:                 
361:                 
362:                 // *****************************************************************************
363:                 /* UART Line Control Mode
364:                 
365:                   Summary:
366:                     UART line control mode.
367:                 
368:                   Description:
369:                     This data type defines the supported line control modes for the UART.
370:                 
371:                   Remarks:
372:                     Some of the line-control options are mutually exclusive:
373:                     * Only one of the "DATA_SIZE" options can be used at a time
374:                     * Only one of the "PARITY" options can be used at a time
375:                     * Only one of the "STOP_BITS" options can be used at a time
376:                 
377:                     The caller should not rely on the specific numbers assigned to any of these
378:                     values as they may change from one processor ot the next.
379:                 */
380:                 
381:                 typedef enum
382:                 {
383:                     // Sets the data transfer size to 8-bits per frame.
384:                     UART_DATA_SIZE_8_BITS   /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
385:                 
386:                     // Sets the data transfer size to 9-bits per frame.
387:                     UART_DATA_SIZE_9_BITS   /*DOM-IGNORE-BEGIN*/= 0x0006/*DOM-IGNORE-END*/,
388:                 
389:                     // Enables parity bit generation for odd parity.
390:                     UART_PARITY_ODD         /*DOM-IGNORE-BEGIN*/= 0x0004/*DOM-IGNORE-END*/,
391:                 
392:                     // Enables parity bit generation for even parity.
393:                     UART_PARITY_EVEN        /*DOM-IGNORE-BEGIN*/= 0x0002/*DOM-IGNORE-END*/,
394:                 
395:                     // Disables parity bit generation.
396:                     UART_PARITY_NONE        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
397:                 
398:                     // Enables generation of 2 stop bits per frame.
399:                     UART_STOP_BITS_2        /*DOM-IGNORE-BEGIN*/= 0x0001/*DOM-IGNORE-END*/,
400:                 
401:                     // Enables generation of 1 stop bit per frame (default).
402:                     UART_STOP_BITS_1        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
403:                 
404:                 } UART_LINE_CONTROL_MODE;
405:                 
406:                 
407:                 // *****************************************************************************
408:                 /* UART Line Status Flags
409:                 
410:                   Summary:
411:                     UART line-status bitmask flags.
412:                 
413:                   Description:
414:                     This enumeration defines the UART line-status bits.  These values are
415:                     OR'd together to make up the bitmask returned by UARTGetLineStatus.
416:                 
417:                   Remarks:
418:                     The caller should not rely on the specific numbers assigned to any of these
419:                     values as they may change from one processor ot the next.
420:                 */
421:                 
422:                 typedef enum
423:                 {
424:                     // The transmitter is able to accept data to transmit.
425:                     UART_TRANSMITTER_NOT_FULL   /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
426:                 
427:                     // The transmitter is empty (no data is available to transmit).
428:                     UART_TRANSMITTER_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
429:                 
430:                     // The receiver is currently idle.
431:                     UART_RECEIVER_IDLE          /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
432:                 
433:                     // A received data parity error was detected.
434:                     UART_PARITY_ERROR           /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
435:                 
436:                     // Data was received that violated the framing protocol (the data word did
437:                     // not start or stop at the appropriate place).  Note:  A break condition
438:                     // will always indicate a framing error.
439:                     UART_FRAMING_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000004/*DOM-IGNORE-END*/,
440:                 
441:                     // The UART has received more data than it can buffer.  Data has been lost.
442:                     UART_OVERRUN_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000002/*DOM-IGNORE-END*/,
443:                 
444:                     // UART data has been received and is avaiable in the FIFO.
445:                     UART_DATA_READY             /*DOM-IGNORE-BEGIN*/= 0x00000001/*DOM-IGNORE-END*/
446:                 
447:                 } UART_LINE_STATUS;
448:                 
449:                 #define UART_LINE_STATUS_MASK   (UART_TRANSMITTER_NOT_FULL | UART_TRANSMITTER_EMPTY |\
450:                                                 UART_RECEIVER_IDLE | UART_PARITY_ERROR | UART_FRAMING_ERROR |\
451:                                                 UART_OVERRUN_ERROR | UART_DATA_READY)
452:                 
453:                 
454:                 
455:                 // *****************************************************************************
456:                 /* UART Data
457:                 
458:                   Summary:
459:                     UART data.
460:                 
461:                   Description:
462:                     This data type defines the supported data sizes for the UART.
463:                 */
464:                 
465:                 typedef union
466:                 {
467:                     // 8-bit data
468:                     struct
469:                     {
470:                         UINT16  data8bit    : 8;
471:                     };
472:                 
473:                     // 9-bit data
474:                     struct
475:                     {
476:                         UINT16  data9bit    : 9;
477:                     };
478:                 
479:                     UINT16 __data;
480:                 } UART_DATA;
481:                 
482:                 
483:                 // *****************************************************************************
484:                 // *****************************************************************************
485:                 // Section: UART Peripheral Library Interface Routines
486:                 // *****************************************************************************
487:                 // *****************************************************************************
488:                 
489:                 
490:                 /*******************************************************************************
491:                   Function:
492:                     void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode )
493:                 
494:                   Summary:
495:                     Enables or disables the given UART module in the desired mode.
496:                 
497:                   Description:
498:                     This routine enables or disables the given UART module in the desired mode.
499:                 
500:                   Precondition:
501:                     The UART module should be appropriately configured before being enabled.
502:                 
503:                   Parameters:
504:                     id    - Identifies the desired UART module.
505:                 
506:                     mode  - Identifies the desired mode of UART operation.
507:                 
508:                   Returns:
509:                     None
510:                 
511:                   Example:
512:                     <code>
513:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
514:                     </code>
515:                 
516:                   Remarks:
517:                     Enabling UART transmissions will immediately cause a TX interrupt to
518:                     indicate that the transmitter needs data, unless the transmitter FIFO/buffer
519:                     was pre-loaded with data.
520:                   *****************************************************************************/
521:                 
522:                 void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode );
523:                 
524:                 
525:                 /*******************************************************************************
526:                   Function:
527:                     void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags )
528:                 
529:                   Summary:
530:                     UART module configuration routine.
531:                 
532:                   Description:
533:                     This routine allows the caller to configure various features of the UART
534:                     module for desired operation.
535:                 
536:                   Precondition:
537:                     None
538:                 
539:                   Parameters:
540:                     id      - Identifies the desired UART module.
541:                 
542:                     flags   - Bit-wise OR of the desired module configuration settings.
543:                 
544:                   Returns:
545:                     None
546:                 
547:                   Example:
548:                     <code>
549:                     UARTConfigure(UART1, UART_RTS_WHEN_RX_NOT_FULL|UART_ENABLE_PINS_CTS_RTS);
550:                     </code>
551:                 
552:                   Remarks:
553:                     Refer to the UART_CONFIGURATION enumerated data type for details on each
554:                     configuration flag.  Note that the bitmask resulting from the bit-wise OR
555:                     of these values will result in a value that is not explicitly defined in
556:                     the enumeration.
557:                   *****************************************************************************/
558:                 
559:                 void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags );
560:                 
561:                 
562:                 /*******************************************************************************
563:                   Function:
564:                     void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode )
565:                 
566:                   Summary:
567:                     Controls UART module TX and RX FIFO operation.
568:                 
569:                   Description:
570:                     This routine allows the caller to configure when interrupts occur relative
571:                     to different "watermark" levels in the UART TX and RX FIFOs (i.e., how full
572:                     or empty the FIFOs are).
573:                 
574:                   Precondition:
575:                     None
576:                 
577:                   Parameters:
578:                     id      - Identifies the desired UART module.
579:                 
580:                     mode    - Bit-wise OR of the desired FIFO mode values.
581:                 
582:                   Returns:
583:                     None
584:                 
585:                   Example:
586:                     <code>
587:                     UARTSetFifoMode(UART1, UART_INTERRUPT_ON_TX_DONE|UART_INTERRUPT_ON_RX_NOT_EMPTY);
588:                     </code>
589:                 
590:                   Remarks:
591:                     Refer to the UART_FIFO_MODE enumerated data type for details on each
592:                     mode flag.  Note that the bitmask resulting from the bit-wise OR
593:                     of these values will result in a value that is not explicitly defined in
594:                     the enumeration.
595:                   *****************************************************************************/
596:                 
597:                 void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode );
598:                 
599:                 
600:                 /*******************************************************************************
601:                   Function:
602:                     UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate )
603:                 
604:                   Summary:
605:                     Routine to set the UART module's desired data data rate.
606:                 
607:                   Description:
608:                     This routine allows the caller to set the desired data rate for the UART.
609:                 
610:                   Precondition:
611:                     The source clock's frequency must be operating at the frequency passed in the
612:                     "sourceClock" parameter.
613:                 
614:                   Parameters:
615:                     id          - Identifies the desired UART module.
616:                 
617:                     sourceClock - Frequency (Hz) of the source clock being provided to the
618:                                   UART module.
619:                 
620:                     dataRate     - Desired data rate (bits per second).
621:                 
622:                   Returns:
623:                     Actual bit rate selected
624:                 
625:                   Example:
626:                     <code>
627:                     #define PERIPHERAL_CLOCK    10000000
628:                     #define DESIRED_DATA_RATE   19200
629:                 
630:                     UINT32    actualDataRate;
631:                 
632:                     actualDataRate = UARTSetDataRate(UART1, PERIPHERAL_CLOCK, DESIRED_DATA_RATE);
633:                     </code>
634:                 
635:                   Remarks:
636:                     Actual data rate selected may be slightly different than the data rate
637:                     requested due to truncation error.
638:                 
639:                     Note:  In normal mode, the maximum possible data rate is sourceClock/16.  If
640:                     the UART_ENABLE_HIGH_SPEED flag is sent to the UARTConfigure routine, then
641:                     the maximum data rate is sourceClock/4.
642:                   *****************************************************************************/
643:                 
644:                 UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate );
645:                 
646:                 
647:                 /*******************************************************************************
648:                   Function:
649:                     UINT32 UARTGetDataRate ( UART_MODULE id, UINT32 sourceClock )
650:                 
651:                   Summary:
652:                     Routine to get the UART module's current data data rate.
653:                 
654:                   Description:
655:                     This routine allows the caller to get the current data rate for the UART module.
656:                 
657:                   Precondition:
658:                     The source clock's frequency must be operating at the frequency passed in the
659:                     "sourceClock" parameter.
660:                 
661:                   Parameters:
662:                     id          - Identifies the desired UART module.
663:                 
664:                     sourceClock - Frequency (Hz) of the source clock being provided to the
665:                                   UART module.
666:                 
667:                   Returns:
668:                     The UART's current data rate (bits per second).
669:                 
670:                   Example:
671:                     <code>
672:                     #define PERIPHERAL_CLOCK    10000000
673:                 
674:                     UINT32    currentDataRate;
675:                 
676:                     currentDataRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
677:                     </code>
678:                 
679:                   Remarks:
680:                     The current (actual) data rate returned may be slightly different than bit
681:                     rate requested due to truncation error.
682:                   *****************************************************************************/
683:                 
684:                 UINT32 UARTGetDataRate( UART_MODULE id, UINT32 sourceClock );
685:                 
686:                 
687:                 /*******************************************************************************
688:                   Function:
689:                         void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode )
690:                 
691:                   Summary:
692:                     Routine to set the UART module's desired line control parameters.
693:                 
694:                   Description:
695:                     This routine allows the caller to select the desired size of the UART data
696:                     frame, the generation of parity and framing parameters (collectively
697:                     referred to as the "line control" mode).
698:                 
699:                   Precondition:
700:                 
701:                   Parameters:
702:                     id      - Identifies the desired UART module.
703:                 
704:                     mode    - This is a bit-wise OR of the desired line control mode flags.
705:                 
706:                   Returns:
707:                     None
708:                 
709:                   Example:
710:                     <code>
711:                     UARTSetLineControl(UART1, UART_DATA_SIZE_8_BITS|UART_PARITY_NONE|UART_STOP_BITS_1);
712:                     </code>
713:                 
714:                   Remarks:
715:                     Refer to the UART_LINE_CONTROL_MODE enumerated data type for details on
716:                     each mode flag.  Note that the bitmask resulting from the bit-wise OR
717:                     of these values will result in a value that is not explicitly defined in
718:                     the enumeration.
719:                   *****************************************************************************/
720:                 
721:                 void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode );
722:                 
723:                 
724:                 /*******************************************************************************
725:                   Function:
726:                     UART_LINE_STATUS UARTGetLineStatus ( UART_MODULE id )
727:                 
728:                   Summary:
729:                     Provides current UART line status.
730:                 
731:                   Description:
732:                     This routine allows the caller to get the current line status of the UART,
733:                     indicating the current state of the transmitter and receiver buffers, and
734:                     if any errors have occurred.
735:                 
736:                   Precondition:
737:                     None
738:                 
739:                   Parameters:
740:                     id      - Identifies the desired UART module.
741:                 
742:                   Returns:
743:                     A bit-wise OR of the current line status flags.
744:                 
745:                   Example:
746:                     <code>
747:                     UART_LINE_STATUS lineStatus;
748:                 
749:                     lineStatus = UARTGetLineStatus(UART1);
750:                     if ( (UART_PARITY_ERROR|UART_FRAMING_ERROR|UART_OVERRUN_ERROR) & lineStatus )
751:                     {
752:                         // Handle receiver error
753:                     }
754:                     </code>
755:                 
756:                   Remarks:
757:                     Refer to the UART_LINE_STATUS enumerated data type for details on each
758:                     status flag.
759:                 
760:                     The receiver line status flags are only valid when data has been received
761:                     and for the data at the top of the RX FIFO.
762:                 
763:                     Note that the bitmask resulting from the bit-wise OR of these values will
764:                     result in a value that is not explicitly defined in the enumeration.
765:                   *****************************************************************************/
766:                 extern inline UART_LINE_STATUS __attribute__((always_inline)) UARTGetLineStatus ( UART_MODULE id )
767:                 {
768:                     return (UART_LINE_STATUS)(uartReg[id]->sta.reg & (UART_LINE_STATUS_MASK));
769:                 }
770:                 
771:                 
772:                 /*******************************************************************************
773:                   Function:
774:                     BOOL UARTTransmitterIsReady ( UART_MODULE id )
775:                 
776:                   Summary:
777:                     Routine to detect if the transmitter is ready to accept data to transmit.
778:                 
779:                   Description:
780:                     This routine determines if the transmitter is ready to accept more data to
781:                     be transmitted.
782:                 
783:                   Precondition:
784:                     The UART module should have been appropriately configured and enabled.
785:                 
786:                   Parameters:
787:                     id      - Identifies the desired UART module.
788:                 
789:                   Returns:
790:                     Boolean identifying whether or not the transmitter is ready:
791:                     * TRUE    - If the transmitter is ready to accept more data
792:                     * FALSE   - If the transmitter is not ready to accept more data
793:                 
794:                   Example:
795:                     <code>
796:                     unsigned char data;
797:                 
798:                     data = 'a';
799:                 
800:                     if (UARTTransmitterIsReady(UART1))
801:                     {
802:                         UARTSendDataByte(UART1, data);
803:                     }
804:                     </code>
805:                 
806:                   Remarks:
807:                   *****************************************************************************/
808:                 
809:                 extern inline BOOL __attribute__ ((always_inline)) UARTTransmitterIsReady ( UART_MODULE id )
810:                 {
811:                     return (BOOL)(!(uartReg[id]->sta.reg & _U1STA_UTXBF_MASK));
9D001480  3C029D01   LUI V0, -25343
9D0014E4  3C029D01   LUI V0, -25343
9D001524  3C029D01   LUI V0, -25343
9D001564  3C029D01   LUI V0, -25343
9D00161C  3C029D01   LUI V0, -25343
9D0016D4  3C029D01   LUI V0, -25343
812:                 }
813:                 
814:                 
815:                 /*******************************************************************************
816:                   Function:
817:                     void UARTSendDataByte ( UART_MODULE id, BYTE data )
818:                 
819:                   Summary:
820:                     Routine to send a byte of data.
821:                 
822:                   Description:
823:                     This routine allows the caller to send a byte of data.
824:                 
825:                   Precondition:
826:                     The UART should have been appropriately configured.  The configuration must
827:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS).  The transmitter must
828:                     have been ready, although not necessarily enabled yet.
829:                 
830:                   Parameters:
831:                     id      - Identifies the desired UART module.
832:                 
833:                     data    - Data byte to be sent.
834:                 
835:                   Returns:
836:                     None
837:                 
838:                   Example:
839:                     <code>
840:                     unsigned char data;
841:                 
842:                     data = 'a';
843:                 
844:                     if (UARTTransmitterIsReady(UART1))
845:                     {
846:                         UARTSendDataByte(UART1, data);
847:                     }
848:                     </code>
849:                 
850:                   Remarks:
851:                     This routine is optimized to send 8-bit (1-byte) data through the UART.
852:                     This is an optimization of the "UARTSendData" routine for 8-bit (or less)
853:                     data.
854:                   *****************************************************************************/
855:                 
856:                 extern inline void __attribute__((always_inline)) UARTSendDataByte ( UART_MODULE id, BYTE data )
857:                 {
858:                     uartReg[id]->tx.reg = data;
9D00149C  304500FF   ANDI A1, V0, 255
9D0014FC  AC430020   SW V1, 32(V0)
9D00153C  24020020   ADDIU V0, ZERO, 32
9D00157C  2402007F   ADDIU V0, ZERO, 127
9D001644  90A50000   LBU A1, 0(A1)
9D0016F0  904200D8   LBU V0, 216(V0)
859:                 }
860:                 
861:                 
862:                 /*******************************************************************************
863:                   Function:
864:                     void UARTSendData ( UART_MODULE id, UART_DATA data )
865:                 
866:                   Summary:
867:                     Routine to send data through the UART.
868:                 
869:                   Description:
870:                     This routine allows the caller to send data of any permitted size through
871:                     the UART.
872:                 
873:                   Precondition:
874:                     The UART module should have been appropriately configured.  The configuration must
875:                     have been for desired data size.  The transmitter must have been ready,
876:                     although not necessarily enabled yet.
877:                 
878:                   Parameters:
879:                     id      - Identifies the desired UART module.
880:                 
881:                     data    - Data to be sent.
882:                 
883:                   Returns:
884:                     None
885:                 
886:                   Example:
887:                     <code>
888:                     UART_DATA data = 0x1ff; //can be 8-bit or 9-bit word, depending on how UART is configured
889:                 
890:                     if (UARTTransmitterIsReady(UART1))
891:                     {
892:                         UARTSendData(UART1, data);
893:                     }
894:                     </code>
895:                 
896:                   Remarks:
897:                     Size of the data word size depends on the current configuration (see
898:                     UARTSetLineControl and UART_LINE_CONTROL_MODE).
899:                   *****************************************************************************/
900:                 
901:                 extern inline void __attribute__((always_inline)) UARTSendData( UART_MODULE id, UART_DATA data )
902:                 {
903:                     uartReg[id]->tx.reg = data.__data;
904:                 }
905:                 
906:                 /*******************************************************************************
907:                   Function:
908:                     BOOL UARTTransmissionHasCompleted ( UART_MODULE id )
909:                 
910:                   Summary:
911:                     Routine to detect if the UART module has finshed transmitting the most recent
912:                     data.
913:                 
914:                   Description:
915:                     This routine determines if the transmitter has finished sending all
916:                     available data.
917:                 
918:                   Preconditions:
919:                     The UART module should have been appropriately configured and enabled and data
920:                     sent to the UART TX buffer.
921:                 
922:                   Parameters:
923:                     id      - Identifies the desired UART module.
924:                 
925:                   Returns:
926:                     Boolean identifying if the transmission has completed:
927:                     * TRUE    - If the transmitter has completed sending the data
928:                     * FALSE   - If the transmitter is still busy sending the data
929:                 
930:                   Example:
931:                     <code>
932:                     if (UARTTransmissionHasCompleted(UART1))
933:                     {
934:                         // Perform any tasks necessary when all data has been sent
935:                     }
936:                     </code>
937:                 
938:                   Remarks:
939:                   *****************************************************************************/
940:                 
941:                 extern inline BOOL __attribute__((always_inline)) UARTTransmissionHasCompleted ( UART_MODULE id )
942:                 {
943:                     return (BOOL)(_U1STA_TRMT_MASK == (uartReg[id]->sta.reg & _U1STA_TRMT_MASK));
944:                 }
945:                 
946:                 
947:                 /*******************************************************************************
948:                   Function:
949:                     BOOL UARTReceivedDataIsAvailable ( UART_MODULE id )
950:                 
951:                   Summary:
952:                     Routine to detect if the receiver has data available.
953:                 
954:                   Description:
955:                     This routine determines if the receiver has data available to be read.
956:                 
957:                   Precondition:
958:                     The UART module must have been configured appropriately and enabled. A complete
959:                     data frame must have been sent to the UART before it will return a TRUE.
960:                 
961:                   Parameters:
962:                     id      - Identifies the desired UART module.
963:                 
964:                   Returns:
965:                     Boolean identifying whether or not data is available:
966:                     * TRUE    - If the receiver has data available
967:                     * FALSE   - If the receiver does not have data availble
968:                 
969:                   Example:
970:                     <code>
971:                     UART_DATA data;
972:                 
973:                     if (UARTReceivedDataIsAvailable(UART1))
974:                     {
975:                         data = UARTGetData(UART1);
976:                     }
977:                     </code>
978:                 
979:                   Remarks:
980:                     This routine provides the same information as the UART_DATA_READY line
981:                     status flag.
982:                   *****************************************************************************/
983:                 
984:                 extern inline BOOL __attribute__((always_inline)) UARTReceivedDataIsAvailable ( UART_MODULE id )
985:                 {
986:                     return (BOOL)(_U1STA_URXDA_MASK == (uartReg[id]->sta.reg & _U1STA_URXDA_MASK));
9D001440  3C029D01   LUI V0, -25343
987:                 }
988:                 
989:                 
990:                 /*******************************************************************************
991:                   Function:
992:                     BYTE UARTGetDataByte ( UART_MODULE id )
993:                 
994:                   Summary:
995:                     Routine to get a byte of data received by the UART.
996:                 
997:                   Description:
998:                     This routine allows the caller to read a byte of data received by the UART.
999:                 
1000:                  Precondition:
1001:                    The UART module must have been appropriately configured, the configuration must
1002:                    have been for 8-bit data (see UART_DATA_SIZE_8_BITS), and the UART must have
1003:                    been enabled.  Also, a complete data frame must have been received by the UART.
1004:                
1005:                  Parameters:
1006:                    id      - Identifies the desired UART module.
1007:                
1008:                  Returns:
1009:                    A byte of data received by the UART.
1010:                
1011:                  Example:
1012:                    <code>
1013:                    unsigned char data;
1014:                
1015:                    if (UARTReceivedDataIsAvailable(UART1))
1016:                    {
1017:                        data = UARTGetDataByte(UART1);
1018:                    }
1019:                    </code>
1020:                
1021:                  Remarks:
1022:                    This routine is optimized for receiving 8-bit data through the UART.
1023:                  *****************************************************************************/
1024:                
1025:                extern inline BYTE __attribute__((always_inline)) UARTGetDataByte ( UART_MODULE id )
1026:                {
1027:                    return (BYTE)uartReg[id]->rx.reg;
9D001458  8C620030   LW V0, 48(V1)
1028:                }
1029:                
1030:                
1031:                /*******************************************************************************
1032:                  Function:
1033:                    UART_DATA UARTGetData ( UART_MODULE id )
1034:                
1035:                  Summary:
1036:                    Routine to get data received by the UART.
1037:                
1038:                  Description:
1039:                    This routine allows the caller to read a data word received by the UART.
1040:                
1041:                  Precondition:
1042:                    The module must have been appropriately configured, the UART module must have been
1043:                    enabled, and a complete data frame must have been received by the UART.
1044:                
1045:                  Parameters:
1046:                    id      - Identifies the desired UART module.
1047:                
1048:                  Returns:
1049:                    Data received by the UART.
1050:                
1051:                  Example:
1052:                    <code>
1053:                    UART_DATA data;
1054:                
1055:                    if (UARTReceivedDataIsAvailable(UART1))
1056:                    {
1057:                        data = UARTGetData(UART1);
1058:                    }
1059:                    </code>
1060:                
1061:                  Remarks:
1062:                    Size of the data word depends on the current configuration (see
1063:                    UARTSetLineControl).
1064:                  *****************************************************************************/
1065:                
1066:                extern inline UART_DATA __attribute__((always_inline)) UARTGetData ( UART_MODULE id )
1067:                {
1068:                    UART_DATA data;
1069:                
1070:                    data.__data = uartReg[id]->rx.reg;
1071:                
1072:                    return data;
1073:                }
1074:                
1075:                
1076:                /*******************************************************************************
1077:                  Function:
1078:                    void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch )
1079:                
1080:                  Summary:
1081:                    Routine to program the address for which the UART module may watch.
1082:                
1083:                  Description:
1084:                    This routine programs the 8-bit address for which the module may watch.
1085:                
1086:                  Precondition:
1087:                    None
1088:                
1089:                  Parameters:
1090:                    id      - Identifies the desired UART module.
1091:                
1092:                    address - 8-bit address for which the module will watch.
1093:                
1094:                    watch   - Determines if the "address watch" mode will be enabled or disabled:
1095:                              * TRUE - Enable address watch mode
1096:                              * FALSE - Disable address watch mode
1097:                
1098:                  Returns:
1099:                    None.
1100:                
1101:                  Example:
1102:                    <code>
1103:                    #define SLAVE_ADDRESS  0x42
1104:                
1105:                    UARTSetAddress(UART1, SLAVE_ADDRESS, TRUE);
1106:                    </code>
1107:                
1108:                  Remarks:
1109:                    The module can be placed into a mode where it will ignore all data received
1110:                    until it identifies the programmed adress.  After the programmed address
1111:                    has been identified, it will begin receiving data normally.  This mode is
1112:                    particularly useful for supporting the IEEE-485 protocol.
1113:                  *****************************************************************************/
1114:                
1115:                void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch );
1116:                
1117:                
1118:                /*******************************************************************************
1119:                  Function:
1120:                    void UARTWatchForAddress ( UART_MODULE id, BOOL watch )
1121:                
1122:                  Summary:
1123:                    Routine to enable or disable recognition of the programmed address byte.
1124:                
1125:                  Description:
1126:                    This routine can enable or disable the "address watch" mode.  In this mode,
1127:                    the UART module will ignore all data until it recognizes the programmed address.
1128:                
1129:                  Precondition:
1130:                    UART should have already been enabled and set with watch address.
1131:                
1132:                  Parameters:
1133:                    id      - Identifies the desired UART module.
1134:                
1135:                    watch   - Determines if the "address watch" mode will be enabled or
1136:                              disabled.
1137:                              * TRUE - Enable address watch mode
1138:                              * FALSE - Disable address watch mode
1139:                
1140:                  Returns:
1141:                    None.
1142:                
1143:                  Example:
1144:                    <code>
1145:                    #define SLAVE_ADDRESS 0x42
1146:                
1147:                    // Set the address, but don't enable the watch until later,
1148:                    // UART continues to receive data normally
1149:                    UARTSetAddress(UART1, SLAVE_ADDRESS, FALSE);
1150:                
1151:                    // ...
1152:                
1153:                    // Now begin to ignore all UART traffic until we are addressed
1154:                    UARTWatchForAddress(UART1, TRUE);
1155:                    </code>
1156:                
1157:                  Remarks:
1158:                    The UART module can be placed into a mode where it will ignore all data received
1159:                    until it identifies the programmed address.  After the programmed address
1160:                    has been identified, it will begin receiving data normally.  This mode is
1161:                    particularly useful for supporting the IEEE-485 protocol.
1162:                  *****************************************************************************/
1163:                
1164:                void UARTWatchForAddress ( UART_MODULE id, BOOL watch );
1165:                
1166:                
1167:                /*******************************************************************************
1168:                  Function:
1169:                    void UARTSendBreak ( UART_MODULE id )
1170:                
1171:                  Summary:
1172:                    Routine to send a break signal from the UART.
1173:                
1174:                  Description:
1175:                    This routine allows the caller to send a break signal (12-bits of '0' data).
1176:                
1177:                  Precondition:
1178:                    The UART should have been appropriately configured.  The transmitter should
1179:                    be idle, although not necessarily enabled yet.
1180:                
1181:                  Parameters:
1182:                    id      - Identifies the desired UART module.
1183:                
1184:                  Returns:
1185:                    None
1186:                
1187:                  Example:
1188:                    <code>
1189:                    if (UARTTransmissionHasCompleted(UART1))
1190:                    {
1191:                        UARTSendBreak(UART1);
1192:                    }
1193:                    </code>
1194:                
1195:                  Remarks:
1196:                    After calling UARTSendBreak (and ensuring that the transmitter is enabled),
1197:                    data may be pre-loaded into the FIFO and it will be send immediately
1198:                    following the break signal.
1199:                  *****************************************************************************/
1200:                
1201:                extern inline void __attribute__((always_inline)) UARTSendBreak ( UART_MODULE id )
1202:                {
1203:                    uartReg[id]->sta.set = _U1STA_UTXBRK_MASK;
1204:                }
1205:                
1206:                
1207:                /*******************************************************************************
1208:                  Function:
1209:                    void UARTStartAutoDataRateDetect ( UART_MODULE id )
1210:                
1211:                  Summary:
1212:                    Routine to automatically determine the data rate (bits-per-second) of an
1213:                    external transmitter to the UART.
1214:                
1215:                  Description:
1216:                    This routine initiates the process of automatically determining the data
1217:                    rate (bits-per-second) of an external transmitter to the UART.
1218:                
1219:                  Precondition:
1220:                    The UART should have been appropriately configured.  The transmitter should
1221:                    be idle, although not necessarily enabled yet.
1222:                
1223:                  Parameters:
1224:                    id      - Identifies the desired UART module.
1225:                
1226:                  Returns:
1227:                    None
1228:                
1229:                  Example:
1230:                    <code>
1231:                    // See "PIC32 Family Reference Manual, Sect. 21 UART" for information on
1232:                    // methods to detect a Break.
1233:                
1234:                    if (breakDetected && useAutoRateDetect)
1235:                    {
1236:                        UARTStartAutoDataRateDetect (UART1);
1237:                    }
1238:                    </code>
1239:                
1240:                  Remarks:
1241:                    The UART module begins measuring the data rate beginning at the next start
1242:                    bit.  The external transmitter should send an alternating pattern (0x55)
1243:                    for the byte to be measured for an effective rate detection.  To ensure
1244:                    an effective measurement sequence, this can be done immediately following
1245:                    a break reception. It is important that this UART module is not
1246:                    transmitting data while it is trying to detect RX baud rate, see the
1247:                    "PIC32 Family Reference Manual, Sect. 21 UART".
1248:                  *****************************************************************************/
1249:                
1250:                extern inline void __attribute__((always_inline)) UARTStartAutoDataRateDetect ( UART_MODULE id )
1251:                {
1252:                   uartReg[id]->mode.set = _U1MODE_ABAUD_MASK;
1253:                }
1254:                
1255:                
1256:                
1257:                /*******************************************************************************
1258:                  Function:
1259:                    BOOL UARTDataRateDetected ( UART_MODULE id )
1260:                
1261:                  Summary:
1262:                    Routine to identify when automatic data rate detection has completed.
1263:                
1264:                  Description:
1265:                    This routine checks to see if automatic data rate detection has completed.
1266:                
1267:                  Precondition:
1268:                    Automatic rate detection should have been previously started.
1269:                
1270:                  Parameters:
1271:                    id      - Identifies the desired UART module.
1272:                
1273:                  Returns:
1274:                    * TRUE    - Indicates that automatic rate detection has completed.
1275:                    * FALSE   - Indicates that automatic rate detection is still ongoing.
1276:                
1277:                  Example:
1278:                    <code>
1279:                    #define PERIPHERAL_CLOCK    10000000
1280:                
1281:                    UINT32 currentRate;
1282:                
1283:                    if (UARTDataRateDetected(UART1))
1284:                    {
1285:                        currentRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
1286:                    }
1287:                    </code>
1288:                
1289:                  Remarks:
1290:                    This routine returns FALSE after automatic rate detection
1291:                    has been started but before rate is detectdd, it will return TRUE
1292:                    at any other time.
1293:                  *****************************************************************************/
1294:                
1295:                extern inline BOOL __attribute__((always_inline)) UARTDataRateDetected ( UART_MODULE id )
1296:                {
1297:                    return (BOOL)(!(uartReg[id]->mode.reg & _U1MODE_ABAUD_MASK));
1298:                }
1299:                
1300:                #ifdef __cplusplus
1301:                  }
1302:                #endif
1303:                
1304:                #endif // _UART_h_
1305:                
---  c:/program files (x86)/microchip/xc32/v1.40/pic32mx/include/peripheral/system.h  -------------------
1:                   /********************************************************************
2:                   
3:                       System Library Interface Definition
4:                   
5:                       Summary:
6:                           This file contains the interface definition for the System
7:                           peripheral library.
8:                   
9:                       Description:
10:                          This library provides functions for configuring the peripheral
11:                          clock, cache settings, and wait states.  For details on the
12:                          register and bit settings used by these functions, refer to the
13:                          PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:        System.h
20:                   * Dependencies:
21:                   * Processor:       PIC32
22:                   * Hardware:        N/A
23:                   * Assembler:       N/A
24:                   * Linker:          N/A
25:                   * Company:         Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the ?Company?) for its PICmicro Microcontroller is intended and
30:                   * supplied to you, the Company?s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                  
51:                  
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  
79:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
80:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
81:                  
82:                  /*********************************************************************
83:                   * SYSTEMConfig Flags
84:                   *********************************************************************/
85:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
86:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
87:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
88:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
89:                  
90:                  /*********************************************************************
91:                   Function:
92:                      unsigned int SYSTEMConfigPB(unsigned int sys_clock)
93:                  
94:                   Description:
95:                      The function sets the PB divider to the optimum value.
96:                  
97:                   PreCondition:
98:                      None
99:                  
100:                  Parameters:
101:                     sys_clock - system clock in Hz
102:                 
103:                  Returns:
104:                     the PB clock frequency in Hz
105:                 
106:                  Side Effects:
107:                     The PB clock may be changed
108:                 
109:                  Overview:
110:                     The function sets the PB divider to the optimum value.
111:                 
112:                  Remarks:
113:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
114:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
115:                 
116:                  Example:
117:                     <code>
118:                     SYSTEMConfigPB(72000000);
119:                     </code>
120:                  ********************************************************************/
121:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
122:                 {
123:                     unsigned int pb_div;
124:                     unsigned int pb_clock;
125:                 
126:                     pb_clock = sys_clock;
127:                 
128:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
129:                     {
130:                         pb_div=OSC_PB_DIV_2;
131:                         pb_clock >>= 1;
132:                     }
133:                     else
134:                     {
135:                         pb_div=OSC_PB_DIV_1;
136:                     }
137:                 
138:                     OSCSetPBDIV(pb_div);
139:                 
140:                     return pb_clock;
141:                 }
142:                 
143:                 
144:                 /*********************************************************************
145:                   Function:
146:                     void SYSTEMConfigWaitStates(unsigned int sys_clock)
147:                 
148:                   Description:
149:                     The function sets the Flash Wait states to the optimum value.
150:                 
151:                   PreCondition:
152:                     None
153:                 
154:                   Parameters:
155:                     sys_clock - system clock in Hz
156:                 
157:                   Returns:
158:                     None
159:                 
160:                   Side Effects:
161:                     The Wait States may be changed
162:                 
163:                   Remarks:
164:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
165:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
166:                 
167:                   Example:
168:                     <code>
169:                     SYSTEMConfigWaitStates(72000000);
170:                     </code>
171:                  ********************************************************************/
172:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
173:                 {
174:                 #ifdef _PCACHE
175:                     unsigned int wait_states;
176:                     unsigned int int_status;
177:                 #endif
178:                 
179:                 #ifdef _PCACHE
180:                     wait_states = 0;
181:                 
182:                     while(sys_clock > FLASH_SPEED_HZ)
183:                     {
184:                         wait_states++;
185:                         sys_clock -= FLASH_SPEED_HZ;
186:                     }
187:                 
188:                     int_status=INTDisableInterrupts();
189:                     mCheConfigure(wait_states);
190:                     INTRestoreInterrupts(int_status);
191:                 
192:                 #endif
193:                 }
194:                 
195:                 /*********************************************************************
196:                   Function:
197:                         unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
198:                 
199:                   Description:
200:                     The function sets the PB divider and the Flash Wait states to the optimum value.
201:                 
202:                   PreCondition:
203:                     None
204:                 
205:                   Parameters:
206:                     sys_clock - system clock in Hz
207:                 
208:                   Returns:
209:                     the PB clock frequency in Hz
210:                 
211:                   Side Effects:
212:                     The PB clock and wait states may be changed
213:                 
214:                   Remarks:
215:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
216:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
217:                 
218:                   Example:
219:                     <code>
220:                     SYSTEMConfigWaitStatesAndPB(72000000);
221:                     </code>
222:                  ********************************************************************/
223:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
224:                 {
225:                 #ifdef _PCACHE
226:                     unsigned int wait_states;
227:                 #endif
228:                     unsigned int pb_clock;
229:                     unsigned int int_status;
230:                 
231:                     pb_clock = SYSTEMConfigPB(sys_clock);
232:                 
233:                 
234:                     // set the flash wait states based on 1 wait state
235:                     // for every 20 MHz
236:                 #ifdef _PCACHE
237:                     wait_states = 0;
238:                 
239:                     while(sys_clock > FLASH_SPEED_HZ)
240:                     {
241:                         wait_states++;
242:                         sys_clock -= FLASH_SPEED_HZ;
243:                     }
244:                 
245:                     int_status=INTDisableInterrupts();
246:                     mCheConfigure(wait_states);
247:                     INTRestoreInterrupts(int_status);
248:                 
249:                 #endif
250:                 
251:                     return pb_clock;
252:                 }
253:                 /*********************************************************************
254:                   Function:
255:                     unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
256:                 
257:                   Description:
258:                     The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
259:                     It also enables the cacheability for the K0 segment.
260:                 
261:                   PreCondition:
262:                     None
263:                 
264:                   Parameters:
265:                     sys_clock - system clock in Hz
266:                 
267:                   Output:
268:                     the PB clock frequency in Hz
269:                 
270:                   Side Effects:
271:                     Sets the PB and Flash Wait states
272:                 
273:                   Remarks:
274:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
275:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
276:                 
277:                   Example:
278:                     <code>
279:                     SYSTEMConfigPerformance(72000000);
280:                     </code>
281:                  ********************************************************************/
282:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
283:                 {
284:                     // set up the wait states
285:                     unsigned int pb_clk;
286:                 #ifdef _PCACHE
287:                     unsigned int cache_status;
288:                 #endif
289:                     unsigned int int_status;
290:                 
291:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
292:                 
293:                     int_status=INTDisableInterrupts();
294:                 
295:                     mBMXDisableDRMWaitState();
296:                 
297:                 #ifdef _PCACHE
298:                     cache_status = mCheGetCon();
299:                     cache_status |= CHE_CONF_PF_ALL;
300:                     mCheConfigure(cache_status);
301:                     CheKseg0CacheOn();
302:                 #endif
303:                 
304:                     INTRestoreInterrupts(int_status);
305:                 
306:                     return pb_clk;
307:                 
308:                 }
309:                 /*********************************************************************
310:                   Function:
311:                     unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
312:                 
313:                   Description:
314:                     The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value,
315:                     based on the flags selected and on the frequency of the system clock.
316:                     It also enables the cacheability for the K0 segment.
317:                 
318:                   PreCondition:
319:                     None
320:                 
321:                   Parameters:
322:                     sys_clock - system clock frequency in Hz
323:                     flags -
324:                         *    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
325:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
326:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
327:                         *    SYS_CFG_ALL          - configure all based on system clock
328:                 
329:                   Returns:
330:                     the PB clock frequency in Hz
331:                 
332:                   Side Effects:
333:                     Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
334:                     wait state to 0.
335:                 
336:                 
337:                   Remarks:
338:                     The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
339:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
340:                 
341:                   Example:
342:                     <code>
343:                     SYSTEMConfig(72000000, SYS_CFG_ALL);
344:                     </code>
345:                  ********************************************************************/
346:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
347:                 {
348:                     unsigned int pb_clk;
349:                     unsigned int int_status;
350:                 #ifdef _PCACHE
351:                     unsigned int cache_status;
352:                 #endif
353:                 
354:                     int_status=INTDisableInterrupts();
9D001830  0F402074   JAL INTDisableInterrupts
9D001834  AFB00018   SW S0, 24(SP)
355:                 
356:                     mBMXDisableDRMWaitState();
9D001838  24040040   ADDIU A0, ZERO, 64
9D00183C  3C03BF88   LUI V1, -16504
9D001840  AC642004   SW A0, 8196(V1)
357:                 
358:                     if(flags & SYS_CFG_WAIT_STATES)
359:                     {
360:                         SYSTEMConfigWaitStates(sys_clock);
361:                     }
362:                 
363:                     if(flags & SYS_CFG_PB_BUS)
364:                     {
365:                         SYSTEMConfigPB(sys_clock);
366:                     }
367:                 
368:                 
369:                 #ifdef _PCACHE
370:                     if(flags & SYS_CFG_PCACHE)
371:                     {
372:                         cache_status = mCheGetCon();
373:                         cache_status |= CHE_CONF_PF_ALL;
374:                         mCheConfigure(cache_status);
375:                         CheKseg0CacheOn();
376:                     }
377:                 #endif
378:                 
379:                     pb_clk = sys_clock;
380:                     pb_clk >>= OSCCONbits.PBDIV;
9D001844  3C03BF81   LUI V1, -16511
9D001848  8C63F000   LW V1, -4096(V1)
381:                 
382:                     INTRestoreInterrupts(int_status);
9D00184C  0F401FF2   JAL INTRestoreInterrupts
9D001850  00402021   ADDU A0, V0, ZERO
383:                 
384:                     return pb_clk;
385:                 
386:                 }
387:                 #ifdef __cplusplus
388:                   }
389:                 #endif
390:                 #endif
391:                 
---  /Volumes/home/c11067/xc32/build/xc32-XC32_v1_40_branch/src48x/gcc/libgcc/libgcc2.c  ----------------
9D007B94  10C00009   BEQ A2, ZERO, 0x9D007BBC
9D007B98  00801021   ADDU V0, A0, ZERO
9D007B9C  24020020   ADDIU V0, ZERO, 32
9D007BA0  00461023   SUBU V0, V0, A2
9D007BA4  18400007   BLEZ V0, 0x9D007BC4
9D007BA8  00C42006   SRLV A0, A0, A2
9D007BC8  00001821   ADDU V1, ZERO, ZERO
9D007BCC  03E00008   JR RA
9D007BD0  00451006   SRLV V0, A1, V0
9D007BC4  00021023   SUBU V0, ZERO, V0
9D007BAC  00451004   SLLV V0, A1, V0
9D007BB0  00C51806   SRLV V1, A1, A2
9D007BB4  03E00008   JR RA
9D007BB8  00441025   OR V0, V0, A0
9D007BBC  03E00008   JR RA
9D007BC0  00A01821   ADDU V1, A1, ZERO
9D007BD4  10C00009   BEQ A2, ZERO, 0x9D007BFC
9D007BD8  00801021   ADDU V0, A0, ZERO
9D007BDC  24030020   ADDIU V1, ZERO, 32
9D007BE0  00661823   SUBU V1, V1, A2
9D007BE4  18600007   BLEZ V1, 0x9D007C04
9D007BE8  00C52804   SLLV A1, A1, A2
9D007C08  00001021   ADDU V0, ZERO, ZERO
9D007C0C  03E00008   JR RA
9D007C10  00641804   SLLV V1, A0, V1
9D007C04  00031823   SUBU V1, ZERO, V1
9D007BEC  00641806   SRLV V1, A0, V1
9D007BF0  00C41004   SLLV V0, A0, A2
9D007BF4  03E00008   JR RA
9D007BF8  00651825   OR V1, V1, A1
9D007BFC  03E00008   JR RA
9D007C00  00A01821   ADDU V1, A1, ZERO
9D003A2C  00C04021   ADDU T0, A2, ZERO
9D003E90  00C04021   ADDU T0, A2, ZERO
9D003A30  00804821   ADDU T1, A0, ZERO
9D003E94  00801021   ADDU V0, A0, ZERO
9D003A34  14E0003B   BNE A3, ZERO, 0x9D003B24
9D003A38  00A01821   ADDU V1, A1, ZERO
9D003E98  14E0003F   BNE A3, ZERO, 0x9D003F98
9D003E9C  00A04821   ADDU T1, A1, ZERO
9D003A3C  00A6102B   SLTU V0, A1, A2
9D003A40  10400048   BEQ V0, ZERO, 0x9D003B64
9D003A44  70C21020   CLZ V0, A2
9D003EA0  00A6182B   SLTU V1, A1, A2
9D003EA4  10600047   BEQ V1, ZERO, 0x9D003FC4
9D003EA8  70C31820   CLZ V1, A2
9D003A48  50400008   BEQL V0, ZERO, 0x9D003A6C
9D003A4C  00083402   SRL A2, T0, 16
9D003EAC  50600008   BEQL V1, ZERO, 0x9D003ED0
9D003EB0  00081C02   SRL V1, T0, 16
9D003A5C  00464004   SLLV T0, A2, V0
9D003EC0  00664004   SLLV T0, A2, V1
9D003A50  00021823   SUBU V1, ZERO, V0
9D003A54  00452804   SLLV A1, A1, V0
9D003A58  00641806   SRLV V1, A0, V1
9D003A60  00651825   OR V1, V1, A1
9D003EB4  00034823   SUBU T1, ZERO, V1
9D003EB8  00652804   SLLV A1, A1, V1
9D003EBC  01244806   SRLV T1, A0, T1
9D003EC4  01254825   OR T1, T1, A1
9D003A64  00444804   SLLV T1, A0, V0
9D003EC8  00641004   SLLV V0, A0, V1
9D003A68  00083402   SRL A2, T0, 16
9D003A6C  0066001B   DIVU V1, A2
9D003A70  00C001F4   TEQ A2, ZERO
9D003A74  00002010   MFHI A0, 0
9D003A78  00005812   MFLO T3, 0
9D003A7C  310CFFFF   ANDI T4, T0, -1
9D003A80  00095402   SRL T2, T1, 16
9D003A84  716C5802   MUL T3, T3, T4
9D003A88  00042400   SLL A0, A0, 16
9D003A8C  008A5025   OR T2, A0, T2
9D003A90  014B682B   SLTU T5, T2, T3
9D003A94  0066001B   DIVU V1, A2
9D003A98  00C001F4   TEQ A2, ZERO
9D003A9C  51A00009   BEQL T5, ZERO, 0x9D003AC4
9D003AA0  014B5023   SUBU T2, T2, T3
9D003AA4  01485021   ADDU T2, T2, T0
9D003AA8  0148182B   SLTU V1, T2, T0
9D003AAC  54600005   BNEL V1, ZERO, 0x9D003AC4
9D003AB0  014B5023   SUBU T2, T2, T3
9D003AB4  014B202B   SLTU A0, T2, T3
9D003AB8  01481821   ADDU V1, T2, T0
9D003ABC  0064500B   MOVN T2, V1, A0
9D003AC0  014B5023   SUBU T2, T2, T3
9D003AC4  3123FFFF   ANDI V1, T1, -1
9D003AC8  0146001B   DIVU T2, A2
9D003ACC  00C001F4   TEQ A2, ZERO
9D003AD0  00004810   MFHI T1, 0
9D003AD4  00002012   MFLO A0, 0
9D003AD8  708C2002   MUL A0, A0, T4
9D003ADC  00094C00   SLL T1, T1, 16
9D003AE0  01234825   OR T1, T1, V1
9D003AE4  0124182B   SLTU V1, T1, A0
9D003AE8  0146001B   DIVU T2, A2
9D003AEC  00C001F4   TEQ A2, ZERO
9D003AF0  50600009   BEQL V1, ZERO, 0x9D003B18
9D003AF4  01244823   SUBU T1, T1, A0
9D003AF8  01284821   ADDU T1, T1, T0
9D003AFC  0128182B   SLTU V1, T1, T0
9D003B00  54600005   BNEL V1, ZERO, 0x9D003B18
9D003B04  01244823   SUBU T1, T1, A0
9D003B08  0124182B   SLTU V1, T1, A0
9D003B0C  01284021   ADDU T0, T1, T0
9D003B10  0103480B   MOVN T1, T0, V1
9D003B14  01244823   SUBU T1, T1, A0
9D003ECC  00081C02   SRL V1, T0, 16
9D003ED0  0123001B   DIVU T1, V1
9D003ED4  006001F4   TEQ V1, ZERO
9D003ED8  00006010   MFHI T4, 0
9D003EDC  00005812   MFLO T3, 0
9D003EE0  310AFFFF   ANDI T2, T0, -1
9D003EE4  00022402   SRL A0, V0, 16
9D003EE8  00003012   MFLO A2, 0
9D003EEC  716A3802   MUL A3, T3, T2
9D003EF0  000C6400   SLL T4, T4, 16
9D003EF4  01842025   OR A0, T4, A0
9D003EF8  0087602B   SLTU T4, A0, A3
9D003EFC  0123001B   DIVU T1, V1
9D003F00  006001F4   TEQ V1, ZERO
9D003F04  1180000B   BEQ T4, ZERO, 0x9D003F34
9D003F08  00872823   SUBU A1, A0, A3
9D003F0C  00882021   ADDU A0, A0, T0
9D003F10  0088282B   SLTU A1, A0, T0
9D003F14  14A00006   BNE A1, ZERO, 0x9D003F30
9D003F18  2566FFFF   ADDIU A2, T3, -1
9D003F1C  0087282B   SLTU A1, A0, A3
9D003F20  10A00004   BEQ A1, ZERO, 0x9D003F34
9D003F24  00872823   SUBU A1, A0, A3
9D003F28  2566FFFE   ADDIU A2, T3, -2
9D003F2C  00882021   ADDU A0, A0, T0
9D003F30  00872823   SUBU A1, A0, A3
9D003F34  3042FFFF   ANDI V0, V0, -1
9D003F38  00A3001B   DIVU A1, V1
9D003F3C  006001F4   TEQ V1, ZERO
9D003F40  00004810   MFHI T1, 0
9D003F44  00003812   MFLO A3, 0
9D003F48  00002012   MFLO A0, 0
9D003F4C  70EA5002   MUL T2, A3, T2
9D003F50  00094C00   SLL T1, T1, 16
9D003F54  01221025   OR V0, T1, V0
9D003F58  004A482B   SLTU T1, V0, T2
9D003F5C  00A3001B   DIVU A1, V1
9D003F60  006001F4   TEQ V1, ZERO
9D003F64  51200009   BEQL T1, ZERO, 0x9D003F8C
9D003F68  00061400   SLL V0, A2, 16
9D003F6C  00481021   ADDU V0, V0, T0
9D003F70  0048402B   SLTU T0, V0, T0
9D003F74  15000004   BNE T0, ZERO, 0x9D003F88
9D003F78  24E4FFFF   ADDIU A0, A3, -1
9D003F7C  004A502B   SLTU T2, V0, T2
9D003F80  24E7FFFE   ADDIU A3, A3, -2
9D003F84  00EA200B   MOVN A0, A3, T2
9D003F88  00061400   SLL V0, A2, 16
9D003F8C  00821025   OR V0, A0, V0
9D003F90  03E00008   JR RA
9D003F94  00001821   ADDU V1, ZERO, ZERO
9D003B64  14C00006   BNE A2, ZERO, 0x9D003B80
9D003B68  71021020   CLZ V0, T0
9D003FC4  14C00006   BNE A2, ZERO, 0x9D003FE0
9D003FC8  71031820   CLZ V1, T0
9D003B6C  24020001   ADDIU V0, ZERO, 1
9D003B70  0046001B   DIVU V0, A2
9D003B74  00C001F4   TEQ A2, ZERO
9D003B78  00004012   MFLO T0, 0
9D003FCC  24030001   ADDIU V1, ZERO, 1
9D003FD0  0066001B   DIVU V1, A2
9D003FD4  00C001F4   TEQ A2, ZERO
9D003FD8  00004012   MFLO T0, 0
9D003B7C  71021020   CLZ V0, T0
9D003FDC  71031820   CLZ V1, T0
9D003B80  5440007D   BNEL V0, ZERO, 0x9D003D78
9D003B84  00484004   SLLV T0, T0, V0
9D003FE0  5460007B   BNEL V1, ZERO, 0x9D0041D0
9D003FE4  00684004   SLLV T0, T0, V1
9D003B88  00A82823   SUBU A1, A1, T0
9D003B8C  00081C02   SRL V1, T0, 16
9D003B90  3107FFFF   ANDI A3, T0, -1
9D003FE8  00A82023   SUBU A0, A1, T0
9D003FEC  00083C02   SRL A3, T0, 16
9D003FF0  310BFFFF   ANDI T3, T0, -1
9D003FF4  24030001   ADDIU V1, ZERO, 1
9D003D78  24090020   ADDIU T1, ZERO, 32
9D003D7C  01224823   SUBU T1, T1, V0
9D0041D0  24020020   ADDIU V0, ZERO, 32
9D0041D4  00431023   SUBU V0, V0, V1
9D003D80  01255006   SRLV T2, A1, T1
9D0041D8  00454806   SRLV T1, A1, V0
9D003D9C  00452804   SLLV A1, A1, V0
9D003DA0  01244806   SRLV T1, A0, T1
9D003DA4  01252825   OR A1, T1, A1
9D0041F4  00652804   SLLV A1, A1, V1
9D0041F8  00441006   SRLV V0, A0, V0
9D0041FC  00452825   OR A1, V0, A1
9D003DAC  00444804   SLLV T1, A0, V0
9D004204  00641004   SLLV V0, A0, V1
9D003D84  00081C02   SRL V1, T0, 16
9D003D88  0143001B   DIVU T2, V1
9D003D8C  006001F4   TEQ V1, ZERO
9D003D90  00003010   MFHI A2, 0
9D003D94  00005812   MFLO T3, 0
9D003D98  3107FFFF   ANDI A3, T0, -1
9D003DA8  00056402   SRL T4, A1, 16
9D003DB0  71675802   MUL T3, T3, A3
9D003DB4  00063400   SLL A2, A2, 16
9D003DB8  01863025   OR A2, T4, A2
9D003DBC  00CB202B   SLTU A0, A2, T3
9D003DC0  0143001B   DIVU T2, V1
9D003DC4  006001F4   TEQ V1, ZERO
9D003DC8  50800006   BEQL A0, ZERO, 0x9D003DE4
9D003DCC  00CB3023   SUBU A2, A2, T3
9D003DD0  00C83021   ADDU A2, A2, T0
9D003DD4  00C8202B   SLTU A0, A2, T0
9D003DD8  10800024   BEQ A0, ZERO, 0x9D003E6C
9D003DDC  00CB502B   SLTU T2, A2, T3
9D003DE0  00CB3023   SUBU A2, A2, T3
9D003DE4  30AAFFFF   ANDI T2, A1, -1
9D003DE8  00C3001B   DIVU A2, V1
9D003DEC  006001F4   TEQ V1, ZERO
9D003DF0  00002010   MFHI A0, 0
9D003DF4  00002812   MFLO A1, 0
9D003DF8  70A72802   MUL A1, A1, A3
9D003DFC  00042400   SLL A0, A0, 16
9D003E00  008A2025   OR A0, A0, T2
9D003E04  0085502B   SLTU T2, A0, A1
9D003E08  00C3001B   DIVU A2, V1
9D003E0C  006001F4   TEQ V1, ZERO
9D003E10  5140FF60   BEQL T2, ZERO, 0x9D003B94
9D003E14  00852823   SUBU A1, A0, A1
9D003E18  00882021   ADDU A0, A0, T0
9D003E1C  0088302B   SLTU A2, A0, T0
9D003E20  54C0FF5C   BNEL A2, ZERO, 0x9D003B94
9D003E24  00852823   SUBU A1, A0, A1
9D003E28  0085502B   SLTU T2, A0, A1
9D003E2C  00883021   ADDU A2, A0, T0
9D003E30  00CA200B   MOVN A0, A2, T2
9D003E34  0B400EE5   J 0x9D003B94
9D003E38  00852823   SUBU A1, A0, A1
9D003E6C  00C82021   ADDU A0, A2, T0
9D003E70  0B400F78   J 0x9D003DE0
9D003E74  008A300B   MOVN A2, A0, T2
9D0041DC  00083C02   SRL A3, T0, 16
9D0041E0  0127001B   DIVU T1, A3
9D0041E4  00E001F4   TEQ A3, ZERO
9D0041E8  00003010   MFHI A2, 0
9D0041EC  00006012   MFLO T4, 0
9D0041F0  310BFFFF   ANDI T3, T0, -1
9D004200  00056C02   SRL T5, A1, 16
9D004208  00001812   MFLO V1, 0
9D00420C  718B5002   MUL T2, T4, T3
9D004210  00063400   SLL A2, A2, 16
9D004214  01A63025   OR A2, T5, A2
9D004218  00CA202B   SLTU A0, A2, T2
9D00421C  0127001B   DIVU T1, A3
9D004220  00E001F4   TEQ A3, ZERO
9D004224  5080000B   BEQL A0, ZERO, 0x9D004254
9D004228  00CA3023   SUBU A2, A2, T2
9D00422C  00C83021   ADDU A2, A2, T0
9D004230  00C8202B   SLTU A0, A2, T0
9D004234  14800006   BNE A0, ZERO, 0x9D004250
9D004238  2583FFFF   ADDIU V1, T4, -1
9D00423C  00CA202B   SLTU A0, A2, T2
9D004240  50800004   BEQL A0, ZERO, 0x9D004254
9D004244  00CA3023   SUBU A2, A2, T2
9D004248  2583FFFE   ADDIU V1, T4, -2
9D00424C  00C83021   ADDU A2, A2, T0
9D004250  00CA3023   SUBU A2, A2, T2
9D004254  30ACFFFF   ANDI T4, A1, -1
9D004258  00C7001B   DIVU A2, A3
9D00425C  00E001F4   TEQ A3, ZERO
9D004260  00002010   MFHI A0, 0
9D004264  00005012   MFLO T2, 0
9D004268  00004812   MFLO T1, 0
9D00426C  714B2802   MUL A1, T2, T3
9D004270  00042400   SLL A0, A0, 16
9D004274  008C2025   OR A0, A0, T4
9D004278  0085602B   SLTU T4, A0, A1
9D00427C  00C7001B   DIVU A2, A3
9D004280  00E001F4   TEQ A3, ZERO
9D004284  5180000B   BEQL T4, ZERO, 0x9D0042B4
9D004288  00031C00   SLL V1, V1, 16
9D00428C  00882021   ADDU A0, A0, T0
9D004290  0088302B   SLTU A2, A0, T0
9D004294  14C00006   BNE A2, ZERO, 0x9D0042B0
9D004298  2549FFFF   ADDIU T1, T2, -1
9D00429C  0085302B   SLTU A2, A0, A1
9D0042A0  50C00004   BEQL A2, ZERO, 0x9D0042B4
9D0042A4  00031C00   SLL V1, V1, 16
9D0042A8  2549FFFE   ADDIU T1, T2, -2
9D0042AC  00882021   ADDU A0, A0, T0
9D0042B0  00031C00   SLL V1, V1, 16
9D0042B4  00852023   SUBU A0, A0, A1
9D0042B8  0B400FFE   J 0x9D003FF8
9D0042BC  01231825   OR V1, T1, V1
9D003B94  00092402   SRL A0, T1, 16
9D003B98  00A3001B   DIVU A1, V1
9D003B9C  006001F4   TEQ V1, ZERO
9D003BA0  00005010   MFHI T2, 0
9D003BA4  00003012   MFLO A2, 0
9D003BA8  70C73002   MUL A2, A2, A3
9D003BAC  000A5400   SLL T2, T2, 16
9D003BB0  01442025   OR A0, T2, A0
9D003BB4  0086502B   SLTU T2, A0, A2
9D003BB8  00A3001B   DIVU A1, V1
9D003BBC  006001F4   TEQ V1, ZERO
9D003BC0  51400009   BEQL T2, ZERO, 0x9D003BE8
9D003BC4  00862023   SUBU A0, A0, A2
9D003BC8  00882021   ADDU A0, A0, T0
9D003BCC  0088282B   SLTU A1, A0, T0
9D003BD0  54A00005   BNEL A1, ZERO, 0x9D003BE8
9D003BD4  00862023   SUBU A0, A0, A2
9D003BD8  0086502B   SLTU T2, A0, A2
9D003BDC  00882821   ADDU A1, A0, T0
9D003BE0  00AA200B   MOVN A0, A1, T2
9D003BE4  00862023   SUBU A0, A0, A2
9D003BE8  3126FFFF   ANDI A2, T1, -1
9D003BEC  0083001B   DIVU A0, V1
9D003BF0  006001F4   TEQ V1, ZERO
9D003BF4  00004810   MFHI T1, 0
9D003BF8  00002812   MFLO A1, 0
9D003BFC  70A72802   MUL A1, A1, A3
9D003C00  00094C00   SLL T1, T1, 16
9D003C04  01264825   OR T1, T1, A2
9D003C08  0125302B   SLTU A2, T1, A1
9D003C0C  0083001B   DIVU A0, V1
9D003C10  006001F4   TEQ V1, ZERO
9D003C14  50C00009   BEQL A2, ZERO, 0x9D003C3C
9D003C18  01254823   SUBU T1, T1, A1
9D003C1C  01284821   ADDU T1, T1, T0
9D003C20  0128182B   SLTU V1, T1, T0
9D003C24  54600005   BNEL V1, ZERO, 0x9D003C3C
9D003C28  01254823   SUBU T1, T1, A1
9D003C2C  0125182B   SLTU V1, T1, A1
9D003C30  01284021   ADDU T0, T1, T0
9D003C34  0103480B   MOVN T1, T0, V1
9D003C38  01254823   SUBU T1, T1, A1
9D003FF8  00023402   SRL A2, V0, 16
9D003FFC  0087001B   DIVU A0, A3
9D004000  00E001F4   TEQ A3, ZERO
9D004004  00006810   MFHI T5, 0
9D004008  00006012   MFLO T4, 0
9D00400C  00004812   MFLO T1, 0
9D004010  718B5002   MUL T2, T4, T3
9D004014  000D6C00   SLL T5, T5, 16
9D004018  01A63025   OR A2, T5, A2
9D00401C  00CA682B   SLTU T5, A2, T2
9D004020  0087001B   DIVU A0, A3
9D004024  00E001F4   TEQ A3, ZERO
9D004028  11A00009   BEQ T5, ZERO, 0x9D004050
9D00402C  00CA2823   SUBU A1, A2, T2
9D004030  00C83021   ADDU A2, A2, T0
9D004034  00C8202B   SLTU A0, A2, T0
9D004038  14800004   BNE A0, ZERO, 0x9D00404C
9D00403C  2589FFFF   ADDIU T1, T4, -1
9D004040  00CA202B   SLTU A0, A2, T2
9D004044  548000A6   BNEL A0, ZERO, 0x9D0042E0
9D004048  2589FFFE   ADDIU T1, T4, -2
9D00404C  00CA2823   SUBU A1, A2, T2
9D004050  3042FFFF   ANDI V0, V0, -1
9D004054  00A7001B   DIVU A1, A3
9D004058  00E001F4   TEQ A3, ZERO
9D00405C  00005010   MFHI T2, 0
9D004060  00003012   MFLO A2, 0
9D004064  00002012   MFLO A0, 0
9D004068  70CB5802   MUL T3, A2, T3
9D00406C  000A5400   SLL T2, T2, 16
9D004070  01421025   OR V0, T2, V0
9D004074  004B502B   SLTU T2, V0, T3
9D004078  00A7001B   DIVU A1, A3
9D00407C  00E001F4   TEQ A3, ZERO
9D004080  51400009   BEQL T2, ZERO, 0x9D0040A8
9D004084  00091400   SLL V0, T1, 16
9D004088  00481021   ADDU V0, V0, T0
9D00408C  0048402B   SLTU T0, V0, T0
9D004090  15000004   BNE T0, ZERO, 0x9D0040A4
9D004094  24C4FFFF   ADDIU A0, A2, -1
9D004098  004B582B   SLTU T3, V0, T3
9D00409C  24C6FFFE   ADDIU A2, A2, -2
9D0040A0  00CB200B   MOVN A0, A2, T3
9D0040A4  00091400   SLL V0, T1, 16
9D0040A8  03E00008   JR RA
9D0040AC  00821025   OR V0, A0, V0
9D0042E0  0B401013   J 0x9D00404C
9D0042E4  00C83021   ADDU A2, A2, T0
9D003B18  00491006   SRLV V0, T1, V0
9D003C3C  00491006   SRLV V0, T1, V0
9D003B1C  03E00008   JR RA
9D003B20  00001821   ADDU V1, ZERO, ZERO
9D003C40  03E00008   JR RA
9D003C44  00001821   ADDU V1, ZERO, ZERO
9D003B24  00A7102B   SLTU V0, A1, A3
9D003B28  14400047   BNE V0, ZERO, 0x9D003C48
9D003B2C  70EA5020   CLZ T2, A3
9D003F98  00A7102B   SLTU V0, A1, A3
9D003F9C  14400044   BNE V0, ZERO, 0x9D0040B0
9D003FA0  70E84020   CLZ T0, A3
9D0040B0  00001821   ADDU V1, ZERO, ZERO
9D0040B4  03E00008   JR RA
9D0040B8  00001021   ADDU V0, ZERO, ZERO
9D003C48  00801021   ADDU V0, A0, ZERO
9D003C4C  03E00008   JR RA
9D003C50  00A01821   ADDU V1, A1, ZERO
9D003B30  15400048   BNE T2, ZERO, 0x9D003C54
9D003B34  240B0020   ADDIU T3, ZERO, 32
9D003FA4  55000045   BNEL T0, ZERO, 0x9D0040BC
9D003FA8  24020020   ADDIU V0, ZERO, 32
9D003B38  00E5102B   SLTU V0, A3, A1
9D003B3C  14400005   BNE V0, ZERO, 0x9D003B54
9D003B40  00861023   SUBU V0, A0, A2
9D003B44  0086402B   SLTU T0, A0, A2
9D003B48  15000089   BNE T0, ZERO, 0x9D003D70
9D003B4C  00801021   ADDU V0, A0, ZERO
9D003FAC  00E5282B   SLTU A1, A3, A1
9D003FB0  14A000C8   BNE A1, ZERO, 0x9D0042D4
9D003FB4  0086302B   SLTU A2, A0, A2
9D003FB8  38C20001   XORI V0, A2, 1
9D003FBC  03E00008   JR RA
9D003FC0  00001821   ADDU V1, ZERO, ZERO
9D0042D4  00001821   ADDU V1, ZERO, ZERO
9D003B50  00861023   SUBU V0, A0, A2
9D003B54  00A72823   SUBU A1, A1, A3
9D003B58  0082202B   SLTU A0, A0, V0
9D003B5C  03E00008   JR RA
9D003B60  00A41823   SUBU V1, A1, A0
9D003C54  016A5823   SUBU T3, T3, T2
9D0040BC  00481023   SUBU V0, V0, T0
9D003C58  01473804   SLLV A3, A3, T2
9D003C5C  01661006   SRLV V0, A2, T3
9D003C60  00473825   OR A3, V0, A3
9D0040C0  01073804   SLLV A3, A3, T0
9D0040C4  00461806   SRLV V1, A2, V0
9D0040C8  00673825   OR A3, V1, A3
9D003C90  01463004   SLLV A2, A2, T2
9D003C64  01656806   SRLV T5, A1, T3
9D0040CC  00455006   SRLV T2, A1, V0
9D003C80  01452804   SLLV A1, A1, T2
9D003C84  01641006   SRLV V0, A0, T3
9D003C88  00451025   OR V0, V0, A1
9D0040E8  01052804   SLLV A1, A1, T0
9D0040EC  00441006   SRLV V0, A0, V0
9D0040F0  00452825   OR A1, V0, A1
9D003C68  00074C02   SRL T1, A3, 16
9D003C6C  01A9001B   DIVU T5, T1
9D003C70  012001F4   TEQ T1, ZERO
9D003C74  00006010   MFHI T4, 0
9D003C78  00001812   MFLO V1, 0
9D003C7C  30EEFFFF   ANDI T6, A3, -1
9D003C8C  00022C02   SRL A1, V0, 16
9D003C94  00004012   MFLO T0, 0
9D003C98  706E7802   MUL T7, V1, T6
9D003C9C  000C6400   SLL T4, T4, 16
9D003CA0  01856025   OR T4, T4, A1
9D003CA4  018F282B   SLTU A1, T4, T7
9D003CA8  01A9001B   DIVU T5, T1
9D003CAC  012001F4   TEQ T1, ZERO
9D003CB0  10A0000A   BEQ A1, ZERO, 0x9D003CDC
9D003CB4  01442004   SLLV A0, A0, T2
9D003CB8  01876021   ADDU T4, T4, A3
9D003CBC  0187282B   SLTU A1, T4, A3
9D003CC0  14A00006   BNE A1, ZERO, 0x9D003CDC
9D003CC4  2468FFFF   ADDIU T0, V1, -1
9D003CC8  018F282B   SLTU A1, T4, T7
9D003CCC  50A00004   BEQL A1, ZERO, 0x9D003CE0
9D003CD0  018F6023   SUBU T4, T4, T7
9D003CD4  2468FFFE   ADDIU T0, V1, -2
9D003CD8  01876021   ADDU T4, T4, A3
9D003CDC  018F6023   SUBU T4, T4, T7
9D003CE0  3042FFFF   ANDI V0, V0, -1
9D003CE4  0189001B   DIVU T4, T1
9D003CE8  012001F4   TEQ T1, ZERO
9D003CEC  00002810   MFHI A1, 0
9D003CF0  00001812   MFLO V1, 0
9D003CF4  00006812   MFLO T5, 0
9D003CF8  706E7002   MUL T6, V1, T6
9D003CFC  00052C00   SLL A1, A1, 16
9D003D00  00A21025   OR V0, A1, V0
9D003D04  004E282B   SLTU A1, V0, T6
9D003D08  0189001B   DIVU T4, T1
9D003D0C  012001F4   TEQ T1, ZERO
9D003D10  50A00006   BEQL A1, ZERO, 0x9D003D2C
9D003D14  00084400   SLL T0, T0, 16
9D003D18  00471021   ADDU V0, V0, A3
9D003D1C  0047282B   SLTU A1, V0, A3
9D003D20  10A0004C   BEQ A1, ZERO, 0x9D003E54
9D003D24  246DFFFF   ADDIU T5, V1, -1
9D003D28  00084400   SLL T0, T0, 16
9D003D2C  01A84025   OR T0, T5, T0
9D003D30  004E1023   SUBU V0, V0, T6
9D003E54  004E282B   SLTU A1, V0, T6
9D003E58  50A0FFB4   BEQL A1, ZERO, 0x9D003D2C
9D003E5C  00084400   SLL T0, T0, 16
9D003E60  246DFFFE   ADDIU T5, V1, -2
9D003E64  0B400F4A   J 0x9D003D28
9D003E68  00471021   ADDU V0, V0, A3
9D0040D0  00071C02   SRL V1, A3, 16
9D0040D4  0143001B   DIVU T2, V1
9D0040D8  006001F4   TEQ V1, ZERO
9D0040DC  00004810   MFHI T1, 0
9D0040E0  00006812   MFLO T5, 0
9D0040E4  30EBFFFF   ANDI T3, A3, -1
9D0040F4  00057402   SRL T6, A1, 16
9D0040F8  00001012   MFLO V0, 0
9D0040FC  71AB6002   MUL T4, T5, T3
9D004100  00094C00   SLL T1, T1, 16
9D004104  012E4825   OR T1, T1, T6
9D004108  012C702B   SLTU T6, T1, T4
9D00410C  0143001B   DIVU T2, V1
9D004110  006001F4   TEQ V1, ZERO
9D004114  11C0000A   BEQ T6, ZERO, 0x9D004140
9D004118  01063004   SLLV A2, A2, T0
9D00411C  01274821   ADDU T1, T1, A3
9D004120  0127502B   SLTU T2, T1, A3
9D004124  15400006   BNE T2, ZERO, 0x9D004140
9D004128  25A2FFFF   ADDIU V0, T5, -1
9D00412C  012C502B   SLTU T2, T1, T4
9D004130  51400004   BEQL T2, ZERO, 0x9D004144
9D004134  012C4823   SUBU T1, T1, T4
9D004138  25A2FFFE   ADDIU V0, T5, -2
9D00413C  01274821   ADDU T1, T1, A3
9D004140  012C4823   SUBU T1, T1, T4
9D004144  30A5FFFF   ANDI A1, A1, -1
9D004148  0123001B   DIVU T1, V1
9D00414C  006001F4   TEQ V1, ZERO
9D004150  00006810   MFHI T5, 0
9D004154  00006012   MFLO T4, 0
9D004158  00005012   MFLO T2, 0
9D00415C  718B5802   MUL T3, T4, T3
9D004160  000D6C00   SLL T5, T5, 16
9D004164  01A52825   OR A1, T5, A1
9D004168  00AB682B   SLTU T5, A1, T3
9D00416C  0123001B   DIVU T1, V1
9D004170  006001F4   TEQ V1, ZERO
9D004174  51A0000B   BEQL T5, ZERO, 0x9D0041A4
9D004178  00021400   SLL V0, V0, 16
9D00417C  00A72821   ADDU A1, A1, A3
9D004180  00A7182B   SLTU V1, A1, A3
9D004184  14600006   BNE V1, ZERO, 0x9D0041A0
9D004188  258AFFFF   ADDIU T2, T4, -1
9D00418C  00AB182B   SLTU V1, A1, T3
9D004190  50600004   BEQL V1, ZERO, 0x9D0041A4
9D004194  00021400   SLL V0, V0, 16
9D004198  258AFFFE   ADDIU T2, T4, -2
9D00419C  00A72821   ADDU A1, A1, A3
9D0041A0  00021400   SLL V0, V0, 16
9D0041A4  01421025   OR V0, T2, V0
9D0041A8  00AB2823   SUBU A1, A1, T3
9D003D34  01060019   MULTU 0, T0, A2
9D003D38  00004810   MFHI T1, 0
9D003D50  00003012   MFLO A2, 0
9D0041AC  00460019   MULTU 0, V0, A2
9D0041B0  00003810   MFHI A3, 0
9D003D3C  0049182B   SLTU V1, V0, T1
9D003D40  1460003E   BNE V1, ZERO, 0x9D003E3C
9D003D44  00004012   MFLO T0, 0
9D003D48  1049004B   BEQ V0, T1, 0x9D003E78
9D003D4C  00491823   SUBU V1, V0, T1
9D003E78  0088182B   SLTU V1, A0, T0
9D003E7C  5460FFF0   BNEL V1, ZERO, 0x9D003E40
9D003E80  01063023   SUBU A2, T0, A2
9D003E84  00003012   MFLO A2, 0
9D003E88  0B400F55   J 0x9D003D54
9D003E8C  00001821   ADDU V1, ZERO, ZERO
9D0041B4  00A7182B   SLTU V1, A1, A3
9D0041B8  14600044   BNE V1, ZERO, 0x9D0042CC
9D0041BC  00003012   MFLO A2, 0
9D0041C0  10A7003F   BEQ A1, A3, 0x9D0042C0
9D0041C4  01042004   SLLV A0, A0, T0
9D0042C0  0086302B   SLTU A2, A0, A2
9D0042C4  10C0FFC0   BEQ A2, ZERO, 0x9D0041C8
9D0042C8  00000000   NOP
9D0041C8  03E00008   JR RA
9D0041CC  00001821   ADDU V1, ZERO, ZERO
9D0042CC  0B401072   J 0x9D0041C8
9D0042D0  2442FFFF   ADDIU V0, V0, -1
9D003E3C  01063023   SUBU A2, T0, A2
9D003E40  01271823   SUBU V1, T1, A3
9D003E44  0106402B   SLTU T0, T0, A2
9D003E48  00681823   SUBU V1, V1, T0
9D003E4C  0B400F55   J 0x9D003D54
9D003E50  00431823   SUBU V1, V0, V1
9D003D54  00863023   SUBU A2, A0, A2
9D003D58  0086202B   SLTU A0, A0, A2
9D003D5C  00641823   SUBU V1, V1, A0
9D003D60  01631004   SLLV V0, V1, T3
9D003D64  01463006   SRLV A2, A2, T2
9D003D68  00461025   OR V0, V0, A2
9D003D6C  01431806   SRLV V1, V1, T2
9D003D70  03E00008   JR RA
9D003D74  00000000   NOP
9D0042D8  03E00008   JR RA
9D0042DC  24020001   ADDIU V0, ZERO, 1
---  /Volumes/home/c11067/xc32/build/xc32-XC32_v1_40_branch/src48x/gcc/libgcc/floatunsisf.c  ------------
9D0078E4  27BDFFE8   ADDIU SP, SP, -24
9D0078E8  AFBF0014   SW RA, 20(SP)
9D0078EC  04800006   BLTZ A0, 0x9D007908
9D0078F0  00801021   ADDU V0, A0, ZERO
9D007908  00042042   SRL A0, A0, 1
9D00790C  30420001   ANDI V0, V0, 1
9D007910  0F401DC8   JAL sitofp
9D007914  00822025   OR A0, A0, V0
9D007918  00402021   ADDU A0, V0, ZERO
9D00791C  0F40145D   JAL fpadd
9D007920  00402821   ADDU A1, V0, ZERO
9D0078F4  0F401DC8   JAL sitofp
9D0078F8  00000000   NOP
9D0078FC  8FBF0014   LW RA, 20(SP)
9D007900  03E00008   JR RA
9D007904  27BD0018   ADDIU SP, SP, 24
9D007924  8FBF0014   LW RA, 20(SP)
9D007928  03E00008   JR RA
9D00792C  27BD0018   ADDIU SP, SP, 24
